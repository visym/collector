URLS=[
"pycollector/index.html",
"pycollector/recognition.html",
"pycollector/user.html",
"pycollector/detection.html",
"pycollector/backend.html",
"pycollector/version.html",
"pycollector/util.html",
"pycollector/globals.html",
"pycollector/dataset.html",
"pycollector/label.html",
"pycollector/video.html",
"pycollector/project.html"
];
INDEX=[
{
"ref":"pycollector",
"url":0,
"doc":""
},
{
"ref":"pycollector.recognition",
"url":1,
"doc":""
},
{
"ref":"pycollector.recognition.ActivityRecognition",
"url":1,
"doc":""
},
{
"ref":"pycollector.recognition.PIP_250k",
"url":1,
"doc":"Activity recognition using people in public - 250k stabilized"
},
{
"ref":"pycollector.recognition.PIP_250k.dump_patches",
"url":1,
"doc":""
},
{
"ref":"pycollector.recognition.PIP_250k.training",
"url":1,
"doc":""
},
{
"ref":"pycollector.recognition.PIP_250k.forward",
"url":1,
"doc":"Same as :meth: torch.nn.Module.forward() . Args:  args: Whatever you decide to pass into the forward method.  kwargs: Keyword arguments are also possible. Return: Your model's output",
"func":1
},
{
"ref":"pycollector.recognition.PIP_370k",
"url":1,
"doc":"Activity recognition using people in public - 250k stabilized"
},
{
"ref":"pycollector.recognition.PIP_370k.dump_patches",
"url":1,
"doc":""
},
{
"ref":"pycollector.recognition.PIP_370k.training",
"url":1,
"doc":""
},
{
"ref":"pycollector.recognition.PIP_370k.forward",
"url":1,
"doc":"Same as :meth: torch.nn.Module.forward() . Args:  args: Whatever you decide to pass into the forward method.  kwargs: Keyword arguments are also possible. Return: Your model's output",
"func":1
},
{
"ref":"pycollector.recognition.ActivityTracker",
"url":1,
"doc":"Activity recognition using people in public - 250k stabilized"
},
{
"ref":"pycollector.recognition.ActivityTracker.dump_patches",
"url":1,
"doc":""
},
{
"ref":"pycollector.recognition.ActivityTracker.training",
"url":1,
"doc":""
},
{
"ref":"pycollector.recognition.ActivityTracker.forward",
"url":1,
"doc":"Overload forward for multi-gpu batch. Don't use torch DataParallel!",
"func":1
},
{
"ref":"pycollector.user",
"url":2,
"doc":""
},
{
"ref":"pycollector.user.User",
"url":2,
"doc":"User class for collector's user management Args: username ([str]): username of pycollector. password ([str], optional): password for the user. Defaults to None."
},
{
"ref":"pycollector.user.User.refresh",
"url":2,
"doc":"",
"func":1
},
{
"ref":"pycollector.user.User.login",
"url":2,
"doc":"[summary] Args: username ([str]): username of pycollector. password ([str], optional): password for the user. Defaults to None.",
"func":1
},
{
"ref":"pycollector.user.User.get_ssm_param",
"url":2,
"doc":"[summary]",
"func":1
},
{
"ref":"pycollector.user.User.is_token_expired",
"url":2,
"doc":"[summary] Returns: [type]: [description]",
"func":1
},
{
"ref":"pycollector.user.User.token_expired_by",
"url":2,
"doc":"",
"func":1
},
{
"ref":"pycollector.user.User.is_authenticated",
"url":2,
"doc":"",
"func":1
},
{
"ref":"pycollector.user.User.add_user_to_group",
"url":2,
"doc":"Check if the current user is already in the pycollector user group, if not add the user to group Returns: [type]: [description]",
"func":1
},
{
"ref":"pycollector.user.User.username",
"url":2,
"doc":""
},
{
"ref":"pycollector.user.User.cognito_username",
"url":2,
"doc":""
},
{
"ref":"pycollector.user.User.lambda_client",
"url":2,
"doc":""
},
{
"ref":"pycollector.detection",
"url":3,
"doc":""
},
{
"ref":"pycollector.detection.TorchNet",
"url":3,
"doc":""
},
{
"ref":"pycollector.detection.FaceDetector",
"url":3,
"doc":"Faster R-CNN based face detector"
},
{
"ref":"pycollector.detection.Yolov5",
"url":3,
"doc":"Yolov5 based object detector >>> d = heyvi.detection.Detector() >>> d(vipy.image.vehicles( .show()"
},
{
"ref":"pycollector.detection.Yolov3",
"url":3,
"doc":"Yolov3 based object detector >>> d = heyvi.detection.Detector() >>> d(vipy.image.vehicles( .show()"
},
{
"ref":"pycollector.detection.ObjectDetector",
"url":3,
"doc":"Default object detector"
},
{
"ref":"pycollector.detection.MultiscaleObjectDetector",
"url":3,
"doc":"Given a list of images, break each one into a set of overlapping tiles, and ObjectDetector() on each, then recombining detections"
},
{
"ref":"pycollector.detection.VideoDetector",
"url":3,
"doc":"Iterate ObjectDetector() over each frame of video, yielding the detected frame"
},
{
"ref":"pycollector.detection.MultiscaleVideoDetector",
"url":3,
"doc":"Given a list of images, break each one into a set of overlapping tiles, and ObjectDetector() on each, then recombining detections"
},
{
"ref":"pycollector.detection.VideoTracker",
"url":3,
"doc":"Default object detector"
},
{
"ref":"pycollector.detection.FaceTracker",
"url":3,
"doc":"Faster R-CNN based face detector"
},
{
"ref":"pycollector.detection.MultiscaleVideoTracker",
"url":3,
"doc":"MultiscaleVideoTracker() class"
},
{
"ref":"pycollector.detection.Proposal",
"url":3,
"doc":"Default object detector"
},
{
"ref":"pycollector.detection.VideoProposal",
"url":3,
"doc":"heyvi.detection.VideoProposal() class. Track-based object proposals in video."
},
{
"ref":"pycollector.detection.FaceProposalRefinement",
"url":3,
"doc":""
},
{
"ref":"pycollector.detection.TrackProposalRefinement",
"url":3,
"doc":""
},
{
"ref":"pycollector.detection.VideoProposalRefinement",
"url":3,
"doc":"heyvi.detection.VideoProposalRefinement() class. Track-based object proposal refinement of a weakly supervised loose object box from a human annotator."
},
{
"ref":"pycollector.detection.ActorAssociation",
"url":3,
"doc":"heyvi.detection.VideoAssociation() class Select the best object track of the target class associated with the primary actor class by gated spatial IOU and distance. Add the best object track to the scene and associate with all activities performed by the primary actor."
},
{
"ref":"pycollector.backend",
"url":4,
"doc":""
},
{
"ref":"pycollector.backend.API",
"url":4,
"doc":"class for pycollector API Args: object ([type]): [description] Args: username ([type], optional): [description]. Defaults to None. password ([type], optional): [description]. Defaults to None."
},
{
"ref":"pycollector.backend.API.get_project",
"url":4,
"doc":"[summary] Args: -",
"func":1
},
{
"ref":"pycollector.backend.API.videos",
"url":4,
"doc":"[summary] Args: -",
"func":1
},
{
"ref":"pycollector.backend.API.lastvideo",
"url":4,
"doc":"",
"func":1
},
{
"ref":"pycollector.backend.API.new_collection",
"url":4,
"doc":"",
"func":1
},
{
"ref":"pycollector.backend.API.list_collections",
"url":4,
"doc":"",
"func":1
},
{
"ref":"pycollector.backend.API.delete_collection",
"url":4,
"doc":"",
"func":1
},
{
"ref":"pycollector.backend.API.login",
"url":2,
"doc":"[summary] Args: username ([str]): username of pycollector. password ([str], optional): password for the user. Defaults to None.",
"func":1
},
{
"ref":"pycollector.backend.API.get_ssm_param",
"url":2,
"doc":"[summary]",
"func":1
},
{
"ref":"pycollector.backend.API.is_token_expired",
"url":2,
"doc":"[summary] Returns: [type]: [description]",
"func":1
},
{
"ref":"pycollector.backend.API.add_user_to_group",
"url":2,
"doc":"Check if the current user is already in the pycollector user group, if not add the user to group Returns: [type]: [description]",
"func":1
},
{
"ref":"pycollector.version",
"url":5,
"doc":""
},
{
"ref":"pycollector.version.num",
"url":5,
"doc":"",
"func":1
},
{
"ref":"pycollector.version.at_least_version",
"url":5,
"doc":"Is versionstring='X.Y.Z' at least the current version?",
"func":1
},
{
"ref":"pycollector.version.is_at_least",
"url":5,
"doc":"Synonym for at_least_version",
"func":1
},
{
"ref":"pycollector.version.is_exactly",
"url":5,
"doc":"",
"func":1
},
{
"ref":"pycollector.util",
"url":6,
"doc":""
},
{
"ref":"pycollector.util.mergedict",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.lowerif",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.isday",
"url":6,
"doc":"Is the yyyymmdd formatted as 'YYYY-MM-DD' such as '2020-03-18'",
"func":1
},
{
"ref":"pycollector.util.isdate",
"url":6,
"doc":"Alias for isday",
"func":1
},
{
"ref":"pycollector.util.fromdate",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.ismonday",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.is_more_recent_than",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.yyyymmdd_to_date",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.is_email_address",
"url":6,
"doc":"Quick and dirty, will throw an error on blank characters if strict=True",
"func":1
},
{
"ref":"pycollector.util.allmondays",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.timestamp_YYYYMMDD_HHMMSS",
"url":6,
"doc":"Datetime stamp in eastern timezone with second resolution",
"func":1
},
{
"ref":"pycollector.util.istimestamp_YYYYMMDD_HHMMSS",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.fromtimestamp_YYYYMMDD_HHMMSS",
"url":6,
"doc":"Assumed eastern timezone",
"func":1
},
{
"ref":"pycollector.util.timestamp",
"url":6,
"doc":"Datetime stamp in eastern timezone with microsecond resolution",
"func":1
},
{
"ref":"pycollector.util.istimestamp",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.fromtimestamp",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.clockstamp",
"url":6,
"doc":"Datetime stamp in eastern timezone with second resolution",
"func":1
},
{
"ref":"pycollector.util.datestamp",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.today",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.fromclockstamp",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.allmondays_since",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.lastmonday",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.lastweek_monday",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.nextsunday",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.nextday",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.globals",
"url":7,
"doc":""
},
{
"ref":"pycollector.globals.cachedir",
"url":7,
"doc":"Set the location to save videos and JSON files when downloaded. This will default to the system temp directory if not set. -This can be set by default by creating the environment variable VIPY_CACHE='/path/to/newdir'",
"func":1
},
{
"ref":"pycollector.globals.logging",
"url":7,
"doc":"Single entry point for enabling/disabling logging vs. printing All vipy functions overload \"from vipy.globals import print\" for simplified readability of code. This global function redirects print or warn to using the standard logging module. If format is provided, this will create a basicConfig handler, but this should be configured by the end-user.",
"func":1
},
{
"ref":"pycollector.globals.warn",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.globals.print",
"url":7,
"doc":"Main entry point for all print statements in the pycollector package. All pycollector code calls this to print helpful messages. -All print() statements in pycollector are overloaded to call pycollector.globals.print() so that it can be redirected to logging as needed -Printing can be disabled by calling pycollector.globals.silent() -Printing can be redirected to standard python logging by calling pycollector.globals.logging(True)",
"func":1
},
{
"ref":"pycollector.globals.verbose",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.globals.silent",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.dataset",
"url":8,
"doc":""
},
{
"ref":"pycollector.dataset.disjoint_activities",
"url":8,
"doc":"",
"func":1
},
{
"ref":"pycollector.dataset.asmeva",
"url":8,
"doc":"Convert a list of collector.dataset.Video() to MEVA annotation style",
"func":1
},
{
"ref":"pycollector.dataset.TorchDataset",
"url":8,
"doc":"Moved to vipy.torch.TorchDataset"
},
{
"ref":"pycollector.dataset.TorchTensordir",
"url":8,
"doc":"Moved to vipy.torch.TorchTensordir"
},
{
"ref":"pycollector.dataset.Dataset",
"url":8,
"doc":"Additional methods beyond  vipy.dataset.Dataset that are specific to collector style datasets"
},
{
"ref":"pycollector.dataset.Dataset.collectors",
"url":8,
"doc":"",
"func":1
},
{
"ref":"pycollector.dataset.Dataset.os",
"url":8,
"doc":"",
"func":1
},
{
"ref":"pycollector.dataset.Dataset.device",
"url":8,
"doc":"",
"func":1
},
{
"ref":"pycollector.label",
"url":9,
"doc":""
},
{
"ref":"pycollector.label.Label",
"url":9,
"doc":""
},
{
"ref":"pycollector.label.piplabel_to_mevalabel",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pycollector.label.mevalabel_to_index",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pycollector.label.piplabel_to_index",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pycollector.label.pip_250k_powerset",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pycollector.video",
"url":10,
"doc":""
},
{
"ref":"pycollector.video.Video",
"url":10,
"doc":"pycollector.video.Video class"
},
{
"ref":"pycollector.video.Video.cast",
"url":10,
"doc":"Cast a conformal vipy object to this class. This is useful for downcast and upcast conversion of video objects.",
"func":1
},
{
"ref":"pycollector.video.Video.from_json",
"url":10,
"doc":"Restore an object serialized with self.json() Usage: >>> vs = vipy.video.Scene.from_json(v.json( ",
"func":1
},
{
"ref":"pycollector.video.Video.json",
"url":10,
"doc":"Return JSON encoded string of this object. This may fail if attributes contain non-json encodeable object",
"func":1
},
{
"ref":"pycollector.video.Video.isedited",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.editedat",
"url":10,
"doc":"Android appends an '_ ' timestamp as milliseconds since epoch (POSIX timestamp), iOS will replace the first '_datetimestr' with a new datetimest",
"func":1
},
{
"ref":"pycollector.video.Video.edited",
"url":10,
"doc":"Return the datetime representation of the editedat() string",
"func":1
},
{
"ref":"pycollector.video.Video.variant",
"url":10,
"doc":"Category variant",
"func":1
},
{
"ref":"pycollector.video.Video.geolocation",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.fetch",
"url":10,
"doc":"Download JSON and MP4 if not already downloaded",
"func":1
},
{
"ref":"pycollector.video.Video.fetchvideo",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.fetchjson",
"url":10,
"doc":"Download JSON if not already downloaded",
"func":1
},
{
"ref":"pycollector.video.Video.is_json_loaded",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.hasjson",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.hasMP4",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.activity_categories",
"url":10,
"doc":"Return a set of unique activity categories in the video, not including object categories",
"func":1
},
{
"ref":"pycollector.video.Video.quicklooks",
"url":10,
"doc":"Return a vipy.image.Image object containing a montage quicklook for each of the activities in this video. Usage: >>> filenames = [im.saveas('/path/to/quicklook.jpg') for im in self.quicklooks()]",
"func":1
},
{
"ref":"pycollector.video.Video.trim",
"url":10,
"doc":"Temporally clip the video so that the video start is the beginning of the first activity, and the end of the video is the end of the last activity. Optionally add a temporal pad of padframes before and after the clip",
"func":1
},
{
"ref":"pycollector.video.Video.timestamp",
"url":10,
"doc":"Return collected_date from json as a datetime object, WARNING: older veresion of the app do not include timezone info in this string, so this datetime is not offset aware",
"func":1
},
{
"ref":"pycollector.video.Video.uploaded",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.metadata",
"url":10,
"doc":"Return a dictionary of metadata about this video. This is an alias for the 'attributes' dictionary.",
"func":1
},
{
"ref":"pycollector.video.Video.videoid",
"url":10,
"doc":"Return a unique video identifier for this video, as specified in the 'video_id' attribute, or by SHA1 hash of the  vipy.video.Video.filename and  vipy.video.Video.url . Args: newid: [str] If not None, then update the video_id as newid. Returns: The video ID if newid=None else self  note - If the video filename changes (e.g. from transformation), and video_id is not set in self.attributes, then the video ID will change. - If a video does not have a filename or URL or a video ID in the attributes, then this will return None - To preserve a video ID independent of transformations, set self.setattribute('video_id', ${MY_ID}), or pass in newid",
"func":1
},
{
"ref":"pycollector.video.Video.collectorid",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.subjectid",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.collectionid",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.collection_name",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.collection",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.duration",
"url":10,
"doc":"Video length in seconds",
"func":1
},
{
"ref":"pycollector.video.Video.quickshow",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.downcast",
"url":10,
"doc":"Convert from pycollector.video to vipy.video.Scene by downcasting class",
"func":1
},
{
"ref":"pycollector.video.Video.upcast",
"url":10,
"doc":"Convert from pycollector.video to pycollector.admin.video by upcasting class, available to admins only",
"func":1
},
{
"ref":"pycollector.video.Video.project",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.program",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.object_detection",
"url":10,
"doc":"Run an object detector on a given frame of video. It is more efficient to construct an ObjectDetector() object once and reuse it.",
"func":1
},
{
"ref":"pycollector.video.Video.face_detection",
"url":10,
"doc":"Run face detection on a given frame of video. It is more efficient to construct a FaceDetector() object once and reuse it.",
"func":1
},
{
"ref":"pycollector.video.Video.faces",
"url":10,
"doc":"Alias for face_detection",
"func":1
},
{
"ref":"pycollector.video.last",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.project",
"url":11,
"doc":""
},
{
"ref":"pycollector.project.Project",
"url":11,
"doc":"collector.project.Project class Projects() are sets of CollectionInstances() and Instances() in a program. Args: username ([str]): username of pycollector. password ([str], optional): password for the user. Defaults to None."
},
{
"ref":"pycollector.project.Project.videos",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.project.Project.last",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.project.Project.login",
"url":2,
"doc":"[summary] Args: username ([str]): username of pycollector. password ([str], optional): password for the user. Defaults to None.",
"func":1
},
{
"ref":"pycollector.project.Project.get_ssm_param",
"url":2,
"doc":"[summary]",
"func":1
},
{
"ref":"pycollector.project.Project.is_token_expired",
"url":2,
"doc":"[summary] Returns: [type]: [description]",
"func":1
},
{
"ref":"pycollector.project.Project.add_user_to_group",
"url":2,
"doc":"Check if the current user is already in the pycollector user group, if not add the user to group Returns: [type]: [description]",
"func":1
}
]