URLS=[
"pycollector/index.html",
"pycollector/admin/index.html",
"pycollector/admin/campaign.html",
"pycollector/admin/dataset.html",
"pycollector/admin/dropbox.html",
"pycollector/admin/globals.html",
"pycollector/admin/gmail.html",
"pycollector/admin/gsheets.html",
"pycollector/admin/label.html",
"pycollector/admin/legacy.html",
"pycollector/admin/program.html",
"pycollector/admin/project.html",
"pycollector/admin/version.html",
"pycollector/admin/backend.html",
"pycollector/admin/review.html",
"pycollector/admin/video.html",
"pycollector/video.html",
"pycollector/admin/workforce.html",
"pycollector/admin/dashboard.html",
"pycollector/admin/util.html",
"pycollector/program/index.html",
"pycollector/program/briar.html",
"pycollector/program/llfr.html",
"pycollector/program/meva.html",
"pycollector/program/pip.html",
"pycollector/program/practice.html",
"pycollector/program/registry.html",
"pycollector/program/cap.html",
"pycollector/backend.html",
"pycollector/user.html",
"pycollector/dataset.html",
"pycollector/globals.html",
"pycollector/project.html",
"pycollector/util.html",
"pycollector/label.html",
"pycollector/version.html"
];
INDEX=[
{
"ref":"pycollector",
"url":0,
"doc":""
},
{
"ref":"pycollector.admin",
"url":1,
"doc":""
},
{
"ref":"pycollector.admin.campaign",
"url":2,
"doc":""
},
{
"ref":"pycollector.admin.campaign.Campaign_v1",
"url":2,
"doc":"collector.project.Campaign A campaign is a mapping of Activities() to set of Collections() for a specific customer. The definition of a campaign is provided in a Google Sheet dashboard for a program, editable by the customer."
},
{
"ref":"pycollector.admin.campaign.Campaign_v1.collections",
"url":2,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.campaign.Campaign_v1.collection",
"url":2,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.campaign.Campaign_v1.price",
"url":2,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.campaign.Campaign_v1.price_per_activity",
"url":2,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.campaign.Campaign_v1.joint_activities",
"url":2,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.campaign.Campaign_v1.collection_names",
"url":2,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.campaign.Campaign_v1.sync",
"url":2,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.campaign.Campaign_v1.training_videos",
"url":2,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.campaign.Campaign_v1.projectlist",
"url":2,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.campaign.Campaign_v1.verbal_consent_statement",
"url":2,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dataset",
"url":3,
"doc":""
},
{
"ref":"pycollector.admin.dataset.make_release",
"url":3,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dataset.fetch_videos",
"url":3,
"doc":"Download all videos and JSON from S3 for a provided project to outdir",
"func":1
},
{
"ref":"pycollector.admin.dataset.export_dataset",
"url":3,
"doc":"Export redistributable dataset. This export directory is ready for a README and zip. Indir = /path/to/src that contains trainset.pkl outdir should be /mypath/src Load redistributable pickle files for train/test/val using: vipy.util.load(outpklfile, datapath=datapath). datapath='/path/to' when videos are stored in /path/to/activity_category/ .mp4",
"func":1
},
{
"ref":"pycollector.admin.dropbox",
"url":4,
"doc":""
},
{
"ref":"pycollector.admin.dropbox.Dropbox",
"url":4,
"doc":""
},
{
"ref":"pycollector.admin.dropbox.Dropbox.upload",
"url":4,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dropbox.Dropbox.link",
"url":4,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.globals",
"url":5,
"doc":""
},
{
"ref":"pycollector.admin.globals.logging",
"url":5,
"doc":"Single entry point for enabling/disabling logging vs. printing All vipy functions overload \"from vipy.globals import print\" for simplified readability of code. This global function redirects print or warn to using the standard logging module. If format is provided, this will create a basicConfig handler, but this should be configured by the end-user.",
"func":1
},
{
"ref":"pycollector.admin.globals.warn",
"url":5,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.globals.print",
"url":5,
"doc":"Main entry point for all print statements in the pycollector package. All pycollector code calls this to print helpful messages. -Printing can be disabled by calling vipy.globals.silent() -Printing can be redirected to logging by calling vipy.globals.logging(True) -All print() statements in vipy. are overloaded to call vipy.globals.print() so that it can be redirected to logging",
"func":1
},
{
"ref":"pycollector.admin.globals.backend",
"url":5,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.globals.setenv",
"url":5,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.globals.api",
"url":5,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.globals.isapi",
"url":5,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.globals.isprod",
"url":5,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.globals.org",
"url":5,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gmail",
"url":6,
"doc":""
},
{
"ref":"pycollector.admin.gmail.Gmail",
"url":6,
"doc":"collector.email.Gmail object for sending gmail from python https: developers.google.com/gmail/api/quickstart/python"
},
{
"ref":"pycollector.admin.gmail.Gmail.send",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gmail.Gmail.mailmerge",
"url":6,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets",
"url":7,
"doc":""
},
{
"ref":"pycollector.admin.gsheets.Gdrive",
"url":7,
"doc":"Create new sheets in a google drive folder with publicly viewable links"
},
{
"ref":"pycollector.admin.gsheets.Gdrive.filelist",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gdrive.urls",
"url":7,
"doc":"List all files in this folder and return a dictionary mapping the filename to a public URL",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gdrive.url",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gdrive.sheet",
"url":7,
"doc":"Return a new sheet in the folder with public viewing permissions, and create it if necessary",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gdrive.editable",
"url":7,
"doc":"Change the permission of the filename to edit with link",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gdrive.viewable",
"url":7,
"doc":"Change the permission of the filename to view only with link",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gdrive.upload",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets",
"url":7,
"doc":"pycollector.admin.gsheets.Gsheets() class for interacting with a shared google spreadsheet"
},
{
"ref":"pycollector.admin.gsheets.Gsheets.url",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.sheetid",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.title",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.checkbox",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.unprotect",
"url":7,
"doc":"Remove all cell protections on sheetname",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.protect",
"url":7,
"doc":"Set the provide range to be editable only by listed editors and no one else",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.rename_sheet",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.hide_sheet",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.write",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.write_column",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.read",
"url":7,
"doc":"Read as list of dictionaries",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.read_sheet",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.read_header",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.read_body",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.has_metadata",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.delete_metadata",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.metadata",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.readcell",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.writecell",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.writecell_multi_ranges",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.get_empty_row",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.insertcell",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.insert_rows",
"url":7,
"doc":"Insert n rows after row i in sheetname",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.insert_array_to_sheetname",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.write_array_to_sheetname",
"url":7,
"doc":"Data must be a list of lists, each entry written to a cell in the sheetname tab",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.export_data_to_sheets",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.clear_data_on_sheets",
"url":7,
"doc":"Clear google sheet data by range",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.clear_sheet",
"url":7,
"doc":"Clear entire google sheet data by range",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.delete_sheet",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.has_sheet",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.delete_sheet1",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.clear_sheet_except_first_row",
"url":7,
"doc":"Clear entire google sheet data by range",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.create_new_sheet",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.create_new_sheet_with_header",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.autoresize",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.firstsheet",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.secondsheet",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.sheetorder",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.add_sheet",
"url":7,
"doc":"Create a new sheet only if the sheet has not already been created",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.add_sheet_with_header",
"url":7,
"doc":"Create a new sheet only if the sheet has not already been created",
"func":1
},
{
"ref":"pycollector.admin.gsheets.Gsheets.update_data_on_sheets",
"url":7,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.label",
"url":8,
"doc":""
},
{
"ref":"pycollector.admin.legacy",
"url":9,
"doc":""
},
{
"ref":"pycollector.admin.legacy.Pnnn_to_project_name",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.legacy.Pnnn_to_project_id",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.legacy.applabel_to_longlabel",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.legacy.is_legacy_collection",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.legacy.applabel_to_piplabel",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.legacy.piplabel_to_mevalabel",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.legacy.mevalabel_to_index",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.legacy.piplabel_to_index",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.legacy.shortname_synonyms",
"url":9,
"doc":"Translation of old shortnames for some older collections, used in pycollector.admin.backend for mapping old shortnames to new shortnames for activity lookup per collection This legacy function is not necessary for the new app which stores the activity names in the JSON.",
"func":1
},
{
"ref":"pycollector.admin.legacy.videoid_v1",
"url":9,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.program",
"url":10,
"doc":""
},
{
"ref":"pycollector.admin.program.Program",
"url":10,
"doc":""
},
{
"ref":"pycollector.admin.program.Program.dashboard",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.program.Program.assign_internal",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.program.Program.assign",
"url":10,
"doc":"Assign all active projects for this program to the list of collector IDs",
"func":1
},
{
"ref":"pycollector.admin.program.Program.unassign",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.program.Program.name",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.program.Program.isarchived",
"url":10,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project",
"url":11,
"doc":""
},
{
"ref":"pycollector.admin.project.Project",
"url":11,
"doc":"collector.project.Project class Projects() are sets of CollectionInstances() and Instances() in a program."
},
{
"ref":"pycollector.admin.project.Project.program",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.weeks",
"url":11,
"doc":"Return a set of weeks as 'YYYY-MM-DD' Mondays in this project",
"func":1
},
{
"ref":"pycollector.admin.project.Project.since",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.clone",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.take",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.takeone",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.takeif",
"url":11,
"doc":"Take n elements from a random sample of size m if f() returns true",
"func":1
},
{
"ref":"pycollector.admin.project.Project.takeoneif",
"url":11,
"doc":"Take n elements from a random sample of size m if f() returns true",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collectioninstances",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.projects",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collectorID",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collectorid",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collectoremail",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collector_email",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collector_emails",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collectors",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collectionID",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collectionid",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collections",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collectioncount",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.uploaded",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.activities",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.videoID",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.videoIDduplicates",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.videoid",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.topandas",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.tolist",
"url":11,
"doc":"Return a list of dictionaries",
"func":1
},
{
"ref":"pycollector.admin.project.Project.filter",
"url":11,
"doc":"Return a Project() clone that has been filtered according to the requested fields, dates are inclusive of endpoints, [since, before]. -collectorid, collectionid, projectid are id names, may be lists -collector is email address -program is a name not an ID",
"func":1
},
{
"ref":"pycollector.admin.project.Project.project",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collector",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.mean_duration",
"url":11,
"doc":"Mean video length of project in seconds, requires parsing JSON",
"func":1
},
{
"ref":"pycollector.admin.project.Project.dedupe",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.fetch",
"url":11,
"doc":"Set vipy.globals.parallel() to desired parallelism",
"func":1
},
{
"ref":"pycollector.admin.project.Project.videos",
"url":11,
"doc":"Cache JSON files and create a list of pycollector.admin.video.Videos",
"func":1
},
{
"ref":"pycollector.admin.project.Project.last",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.videoscores",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.verified_videos",
"url":11,
"doc":"Cache JSON files and create a list of collector.project.Videos that have passed verification",
"func":1
},
{
"ref":"pycollector.admin.project.Project.ratedinstances",
"url":11,
"doc":"This is the recommended way to retrieve instances that include any associated ratings (may be unrated) to avoid iterative fetch of ratings",
"func":1
},
{
"ref":"pycollector.admin.project.Project.unratedinstances",
"url":11,
"doc":"This is the recommended way to retrieve all unrated instances from the project to avoid iterative fetch of ratings for each instance",
"func":1
},
{
"ref":"pycollector.admin.project.Project.instances",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.rawinstances",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.ratings",
"url":11,
"doc":"Query ratings table for videoids in this project, and filter by reviewer. If badonly=True, then return only reviews that were bad for some reason",
"func":1
},
{
"ref":"pycollector.admin.project.Project.Ratings",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.Rating",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.instanceratings",
"url":11,
"doc":"Return instance objects for all ratings for this project, filtered by reviewer and badonly",
"func":1
},
{
"ref":"pycollector.admin.project.Project.submittedby",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collectorcount",
"url":11,
"doc":"Return number of submitted videos per collector, sorted in decreasing order",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collector_collection_count",
"url":11,
"doc":"Return number of submitted videos per collector per collection, sorted in decreasing order",
"func":1
},
{
"ref":"pycollector.admin.project.Project.bestcollectors",
"url":11,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.project.Project.collectorfeedback",
"url":11,
"doc":"Return the number of uploaded videos and ratings score for the time period in the constructor",
"func":1
},
{
"ref":"pycollector.admin.project.Project.quickhtml",
"url":11,
"doc":"Generate a quicklook HTML file to show all quicklooks in the current project. This is useful for filtering by collector and regenerating quicklooks on demand. Note that this regenrates the quicklooks on demand and does not pull from the backend.",
"func":1
},
{
"ref":"pycollector.admin.project.Project.quicklookurls",
"url":11,
"doc":"Generate a standalong HTML file containing the quicklook URLs for the current filtered project",
"func":1
},
{
"ref":"pycollector.admin.version",
"url":12,
"doc":""
},
{
"ref":"pycollector.admin.version.num",
"url":12,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.version.at_least_version",
"url":12,
"doc":"Is versionstring='X.Y.Z' at least the current version?",
"func":1
},
{
"ref":"pycollector.admin.version.is_at_least",
"url":12,
"doc":"Synonym for at_least_version",
"func":1
},
{
"ref":"pycollector.admin.version.at_least_major_version",
"url":12,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend",
"url":13,
"doc":""
},
{
"ref":"pycollector.admin.backend.Backend",
"url":13,
"doc":"Standard interface for Collector backend"
},
{
"ref":"pycollector.admin.backend.Backend.label",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.program",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.project",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.activity",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.collections",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.collection_assignment",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.collectors",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.subjects",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.instances",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.videos",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.ratings",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.s3_bucket",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.s3_public_bucket",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.ddb_instance",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.ddb_video",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.ddb_collector",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.ddb_rating",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.ddb_review_assignment",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.cognito_client_id",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.environment_name",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.aws_sns_topic_arn",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.video_processing_lambda_function_arn",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.s3_url",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.s3_public_url",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.s3_client",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.isprod",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.name",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Backend.application_initialization",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Test",
"url":13,
"doc":"Standard interface for Collector backend"
},
{
"ref":"pycollector.admin.backend.Dev",
"url":13,
"doc":"Standard interface for Collector backend"
},
{
"ref":"pycollector.admin.backend.Prod_v1",
"url":13,
"doc":"Standard interface for Collector backend"
},
{
"ref":"pycollector.admin.backend.Prod",
"url":13,
"doc":"Standard interface for Collector backend"
},
{
"ref":"pycollector.admin.backend.Project",
"url":13,
"doc":"collector.backend.Project An interface to the Projects table"
},
{
"ref":"pycollector.admin.backend.Project.dict",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Project.get_all_projects_in_df",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Project.new",
"url":13,
"doc":"Add new project (if not present). Check with the latest state in DynamoDB Args: name (str): name of the program client (str): the client associate with the program",
"func":1
},
{
"ref":"pycollector.admin.backend.Project.name_to_id",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Project.id_to_name",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Project.id_to_program_name",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Project.name_to_program_name",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Program",
"url":13,
"doc":"collector.backend.Programs An interface to the Programs table"
},
{
"ref":"pycollector.admin.backend.Program.dict",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Program.new",
"url":13,
"doc":"Add new program (if not present). Check with the latest state in DynamoDB Args: name (str): name of the program client (str): the client associate with the program",
"func":1
},
{
"ref":"pycollector.admin.backend.Program.program_names",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Program.programs",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Program.isprogram",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Program.name_to_id",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Program.id_to_name",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Activity",
"url":13,
"doc":"collector.backend.Activity class An interface to the Activity table which defines the relationship between collections and activities."
},
{
"ref":"pycollector.admin.backend.Activity.activities",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Activity.activity_id",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Activity.to_shortname",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Activity.labels",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Activity.dict",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Activity.new",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Activity.filter",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection",
"url":13,
"doc":"collector.admin.backend.Collection A single collection, as specified in the Collections table. Each Collection() is grouped into Collections()."
},
{
"ref":"pycollector.admin.backend.Collection.project",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.program",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.id",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.creator_cognito_username",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.consent_overlay_text",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.name",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.variant",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.joint_activities",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.activities",
"url":13,
"doc":"Activity categories for this collection, immutable. Includes joint activities specified in activity fragment",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.activity_variants",
"url":13,
"doc":"Activity categories for this collection, immutable",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.joint_shortnames",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.shortnames",
"url":13,
"doc":"Shortnames for activites in this collection, immutable (v2 only). May include joint activities specified in activity fragment",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.shortlabels",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.num_activities",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.num_joint_activities",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.shortname_to_activity",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.has_shortname",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.object_to_shortname",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.activity_to_shortname",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.default_object",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.actor",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.secondary_objects",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.dict",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.enable",
"url":13,
"doc":"Mutable",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.enabled",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.isenabled",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.update",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.disable",
"url":13,
"doc":"Mutable",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.description",
"url":13,
"doc":"Mutable",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.clear_training_videos",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.training_videos",
"url":13,
"doc":"Mutable",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.has_required_consent",
"url":13,
"doc":"Mutable",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.isconsented",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.has_required_training",
"url":13,
"doc":"Mutable",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.has_required_joint_label",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.has_required_viewpoint",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.has_required_style",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.has_required_pose",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.has_required_illumination",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.has_required_location",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.has_required_objects",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.required_pose",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.required_viewpoint",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.required_illumination",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.required_location",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.required_style",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.required_joint_label",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.required_objects",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.objects",
"url":13,
"doc":"Objects for this collection, immutable",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.variantdict",
"url":13,
"doc":"Parse variant() and return a dictionary of variant (key,values) pairs",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.joint_shortname",
"url":13,
"doc":"Joint activities are represented as fragments, person_walks Joint=$ACTIVITY:$SHORTLABEL where the joint activity occurs simultaneously with the primary activity",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.joint_activity",
"url":13,
"doc":"Joint activities are represented as fragments, person_walks Joint=$ACTIVITY:$SHORTLABEL where the joint activity occurs simultaneously with the primary activity",
"func":1
},
{
"ref":"pycollector.admin.backend.Collection.clone",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections",
"url":13,
"doc":"collector.backend.Collections class An interface to the Collections table which is a group of Collection() objects."
},
{
"ref":"pycollector.admin.backend.Collections.union",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.delete",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.filter",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.programs",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.projects",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.project",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.collectionids",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.iscollection",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.iscollectionid",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.collection",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.id_to_name",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.name_to_id",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.collections",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.collectionlist",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.collection_names",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.to_df",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Collections.new",
"url":13,
"doc":"Create new collections with activities and objects details Args: name ([string]): the name of the collection activities ([list]): list of activities program_name ([type]): [description] project_name ([type]): [description] description ([type]): [description] activity_short_names ([list]): list of activities names to be shown on buttons objects ([list]): list of objects training_videos ([type], optional): [description]. Defaults to None. Returns: [type]: [description]",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionAssignment",
"url":13,
"doc":"class for CollectionAssignment"
},
{
"ref":"pycollector.admin.backend.CollectionAssignment.active_collectors",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionAssignment.num_assigned",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionAssignment.emails",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionAssignment.is_new_assignment",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionAssignment.is_already_assigned",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionAssignment.assigned",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionAssignment.assigned_by_email",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionAssignment.histogram",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionAssignment.training_videos",
"url":13,
"doc":"Modify training videos for collectors. Be sure to sync() when complete",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionAssignment.assign",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionAssignment.dict",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionAssignment.unassign",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionAssignment.sync",
"url":13,
"doc":"Write-back of tabledict to DDB",
"func":1
},
{
"ref":"pycollector.admin.backend.Ratings",
"url":13,
"doc":"Fetch all ratings for a given reviewer_email (not reviewer_id) - This will return a huge number of reviews, so use with caution!",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating",
"url":13,
"doc":"collector.backend.Rating() class An interface to the ratings table. ratingdict is a single row of the table"
},
{
"ref":"pycollector.admin.backend.Rating.reviewer",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.review_score",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.isperfect",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_processed",
"url":13,
"doc":"Has a rating been processed by the lambda function yet? This is a legacy function that should never return False for the current system",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.isgood",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_good",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.instanceid",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.videoid",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.instance_id",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_repeated_scene",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_awkward",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_warning",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_viewpoint",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_consent",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_box_big",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_box_small",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_label",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_timing",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_alignment",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_visibility",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_illumination",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_joint_label",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_style",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_video",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_location",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_pose",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.is_bad_objects",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.rating_responses",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.reviewlist",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.review_reason",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.updated",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.Rating.submitted",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance",
"url":13,
"doc":"collector.backend.CollectionInstance class A CollectionInstance() is an observed Collection() made up of one or more Instance() of a specified Activity()"
},
{
"ref":"pycollector.admin.backend.CollectionInstance.collector",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.video",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.has_rating",
"url":13,
"doc":"FIXME: these ratings are inconsistent with the instance table. do not use",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.is_good",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.is_bad_viewpoint",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.is_repeated_scene",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.is_awkward",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.uploaded",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.uploaded_date",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.thumbnail",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.review_score",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.name",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.videoid",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.subjectid",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.backend.CollectionInstance.collectorid",
"url":13,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review",
"url":14,
"doc":""
},
{
"ref":"pycollector.admin.review.choice",
"url":14,
"doc":" Generates a random sample from a given 1-D array  versionadded 1.7.0  note New code should use the  choice method of a  default_rng() instance instead; please see the :ref: random-quick-start . Parameters      a : 1-D array-like or int If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if it were  np.arange(a) size : int or tuple of ints, optional Output shape. If the given shape is, e.g.,  (m, n, k) , then  m  n  k samples are drawn. Default is None, in which case a single value is returned. replace : boolean, optional Whether the sample is with or without replacement. Default is True, meaning that a value of  a can be selected multiple times. p : 1-D array-like, optional The probabilities associated with each entry in a. If not given, the sample assumes a uniform distribution over all entries in  a . Returns    - samples : single item or ndarray The generated random samples Raises    ValueError If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size See Also     randint, shuffle, permutation Generator.choice: which should be used in new code Notes   - Setting user-specified probabilities through  p uses a more general but less efficient sampler than the default. The general sampler produces a different sample than the optimized sampler even if each element of  p is 1 / len(a). Sampling random rows from a 2-D array is not possible with this function, but is possible with  Generator.choice through its  axis keyword. Examples     Generate a uniform random sample from np.arange(5) of size 3: >>> np.random.choice(5, 3) array([0, 3, 4])  random >>>  This is equivalent to np.random.randint(0,5,3) Generate a non-uniform random sample from np.arange(5) of size 3: >>> np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0]) array([3, 3, 0])  random Generate a uniform random sample from np.arange(5) of size 3 without replacement: >>> np.random.choice(5, 3, replace=False) array([3,1,0])  random >>>  This is equivalent to np.random.permutation(np.arange(5 [:3] Generate a non-uniform random sample from np.arange(5) of size 3 without replacement: >>> np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0]) array([2, 3, 0])  random Any of the above can be repeated with an arbitrary array-like instead of just integers. For instance: >>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher'] >>> np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3]) array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'],  random dtype='<U11')",
"func":1
},
{
"ref":"pycollector.admin.review.push_review_sheet_to_s3",
"url":14,
"doc":"Upload file from localPath to backend and return URL",
"func":1
},
{
"ref":"pycollector.admin.review.App",
"url":14,
"doc":""
},
{
"ref":"pycollector.admin.review.App.delete",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.App.assigned",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.App.unassign",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.App.reassign",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.App.videoid",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.App.num_assignments",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.App.completion_rate",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.App.assignments",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.App.assign",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.Sheet",
"url":14,
"doc":""
},
{
"ref":"pycollector.admin.review.Sheet.byvideoid",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.Sheet.assigned_reviews",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.Sheet.completed_reviews",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.Sheet.missed_reviews",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.Sheet.num_assignments",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.Sheet.completion_rate",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.Sheet.num_completed",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.Sheet.assignments",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.Sheet.sheets",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.review.get_review_html",
"url":14,
"doc":"Generate Review HTML sheets for the quicklooks provided",
"func":1
},
{
"ref":"pycollector.admin.review.delete",
"url":14,
"doc":"Delete all reviews assocated with the list of videoid",
"func":1
},
{
"ref":"pycollector.admin.review.videoid",
"url":14,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video",
"url":15,
"doc":""
},
{
"ref":"pycollector.admin.video.Video",
"url":15,
"doc":"pycollector.admin.video.Video class A Video() is an observed CollectionInstance() as spcified by a Collection() and returned as a pycollector.video.Video() object with extra admin-only methods."
},
{
"ref":"pycollector.admin.video.Video.cast",
"url":15,
"doc":"Cast a conformal vipy object to this class. This is useful for downcast and upcast conversion of video objects.",
"func":1
},
{
"ref":"pycollector.admin.video.Video.edits",
"url":15,
"doc":"Return a list of videos corresponding to historical edits for this video",
"func":1
},
{
"ref":"pycollector.admin.video.Video.edit_history",
"url":15,
"doc":"Alias for edits()",
"func":1
},
{
"ref":"pycollector.admin.video.Video.query",
"url":15,
"doc":"Query the videos table for this video ID and store the results in self.attributes['admin']",
"func":1
},
{
"ref":"pycollector.admin.video.Video.sanitize_emails",
"url":15,
"doc":"Replace identifying email addresses 'me@here.com' with a truncated sha1 hash. This is repeatable, so the same email address gets the same hash (not including email typos!)",
"func":1
},
{
"ref":"pycollector.admin.video.Video.downcast",
"url":15,
"doc":"Convert from pycollector.admin.video to pycollector.video by downcasting class, removing __admin attributes",
"func":1
},
{
"ref":"pycollector.admin.video.Video.thumbnail_url",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.week",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.raw_video_file_path",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.annotation_file_path",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.obfuscate",
"url":15,
"doc":"Replace identifying email addresses 'me@here.com' with 'm @here.com. For stronger privacy, use self.sanitize()",
"func":1
},
{
"ref":"pycollector.admin.video.Video.timestamp",
"url":15,
"doc":"Return collected_date from json as a datetime object, WARNING: older veresion of the app do not include timezone info in this string, so this datetime is not offset aware",
"func":1
},
{
"ref":"pycollector.admin.video.Video.quicklookurls",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.animated_quicklookurls",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.rating",
"url":15,
"doc":"Return all instance ratings for this video",
"func":1
},
{
"ref":"pycollector.admin.video.Video.Rating",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.Ratings",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.ratings",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.review",
"url":15,
"doc":"Review this video by creating a review sheet containing just these instnaces and opening in a web browser",
"func":1
},
{
"ref":"pycollector.admin.video.Video.collectoremail",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.collector",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.device",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.isgood",
"url":15,
"doc":"'Good' is defined as a video with at least one instance rated good in the video",
"func":1
},
{
"ref":"pycollector.admin.video.Video.instances",
"url":15,
"doc":"Return all instances for this video by fetching from the database",
"func":1
},
{
"ref":"pycollector.admin.video.Video.instance",
"url":15,
"doc":"Instance by index, fetch from DDB",
"func":1
},
{
"ref":"pycollector.admin.video.Video.instancedict",
"url":15,
"doc":"Return a dictionary of instance ID to activityclip for this video - does not require database fetch.  warning: This will be wrong after calling activityclip() or activitysplit()",
"func":1
},
{
"ref":"pycollector.admin.video.Video.instancelist",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.instanceid",
"url":15,
"doc":"Return a dictionary of instance ID to activityclip for this video - does not require database fetch",
"func":1
},
{
"ref":"pycollector.admin.video.Video.corrupt",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.isaudit",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Video.from_json",
"url":16,
"doc":"Restore an object serialized with self.json() Usage:   vs = vipy.video.Scene.from_json(v.json(  ",
"func":1
},
{
"ref":"pycollector.admin.video.Video.json",
"url":16,
"doc":"Return JSON encoded string of this object. This may fail if attributes contain non-json encodeable object",
"func":1
},
{
"ref":"pycollector.admin.video.Video.appjson",
"url":16,
"doc":"Export JSON that is equivalent to the output of the mobile app, with annotations relative to the video file (not the filter chain)",
"func":1
},
{
"ref":"pycollector.admin.video.Video.editedat",
"url":16,
"doc":"Android appends an '_ ' timestamp as milliseconds since epoch (POSIX timestamp), iOS will replace the first '_datetimestr' with a new datetimest",
"func":1
},
{
"ref":"pycollector.admin.video.Video.edited",
"url":16,
"doc":"Return the datetime representation of the editedat() string",
"func":1
},
{
"ref":"pycollector.admin.video.Video.variant",
"url":16,
"doc":"Category variant",
"func":1
},
{
"ref":"pycollector.admin.video.Video.fetch",
"url":16,
"doc":"Download JSON and MP4 if not already downloaded",
"func":1
},
{
"ref":"pycollector.admin.video.Video.fetchjson",
"url":16,
"doc":"Download JSON if not already downloaded",
"func":1
},
{
"ref":"pycollector.admin.video.Video.activity_categories",
"url":16,
"doc":"Return a set of unique activity categories in the video, not including object categories",
"func":1
},
{
"ref":"pycollector.admin.video.Video.quicklooks",
"url":16,
"doc":"Return a vipy.image.Image object containing a montage quicklook for each of the activities in this video. Usage: >>> filenames = [im.saveas('/path/to/quicklook.jpg') for im in self.quicklooks()]",
"func":1
},
{
"ref":"pycollector.admin.video.Video.trim",
"url":16,
"doc":"Temporally clip the video so that the video start is the beginning of the first activity, and the end of the video is the end of the last activity. Optionally add a temporal pad of padframes before and after the clip",
"func":1
},
{
"ref":"pycollector.admin.video.Video.metadata",
"url":16,
"doc":"Return a dictionary of metadata about this video. Args: k [str]: If provided, return just the specified key of the attributes dictionary, otherwise return the attributes dictionary Returns: The 'attributes' dictionary, or just the value for the provided key k if provided",
"func":1
},
{
"ref":"pycollector.admin.video.Video.videoid",
"url":16,
"doc":"Return a unique video identifier for this video, as specified in the 'video_id' attribute, or by SHA1 hash of the  vipy.video.Video.filename and  vipy.video.Video.url . Args: newid: [str] If not None, then update the video_id as newid. Returns: The video ID if newid=None else self  note - If the video filename changes (e.g. from transformation), and video_id is not set in self.attributes, then the video ID will change. - If a video does not have a filename or URL or a video ID in the attributes, then this will return None - To preserve a video ID independent of transformations, set self.setattribute('video_id', ${MY_ID}), or pass in newid",
"func":1
},
{
"ref":"pycollector.admin.video.Video.duration",
"url":16,
"doc":"Video length in seconds",
"func":1
},
{
"ref":"pycollector.admin.video.Video.upcast",
"url":16,
"doc":"Convert from pycollector.video to pycollector.admin.video by upcasting class, available to admins only",
"func":1
},
{
"ref":"pycollector.admin.video.Video.object_detection",
"url":16,
"doc":"Run an object detector on a given frame of video. It is more efficient to construct an ObjectDetector() object once and reuse it.",
"func":1
},
{
"ref":"pycollector.admin.video.Video.face_detection",
"url":16,
"doc":"Run face detection on a given frame of video. It is more efficient to construct a FaceDetector() object once and reuse it.",
"func":1
},
{
"ref":"pycollector.admin.video.Video.faces",
"url":16,
"doc":"Alias for face_detection",
"func":1
},
{
"ref":"pycollector.admin.video.Instance",
"url":15,
"doc":"pycollector.admin.video.Instance class An Instance() is an observed Activity() collected as part of a CollectionInstance() and spcified by a Collection()"
},
{
"ref":"pycollector.admin.video.Instance.dict",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.collector",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.collectoremail",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.collectorid",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.startframe",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.endframe",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.collection",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.project",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.collectionid",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.uploaded",
"url":15,
"doc":"The datetime string when the instance was created, may be after when the original video was uploaded if edited",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.video_uploaded_datetime",
"url":15,
"doc":"The datetime string when the original video was collected",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.isbackground",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.video_uploaded",
"url":15,
"doc":"Alias for video_uploaded_datetime",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.video_uploaded_daysago",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.is_video_archived",
"url":15,
"doc":"An archived video is one with video_uploaded date greater than a week",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.isedited",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.isobsolete",
"url":15,
"doc":"An obsolete instance is one that is edited, and the ratings are for the old instance and needs to be refreshed",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.is_stale",
"url":15,
"doc":"This instance has ratings but they are outdated",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.isvalid",
"url":15,
"doc":"There are instances that exist as quicklooks that do no exist in the instances table due to repeats, allow for non-strict loading (check with isvalid() so that we can load in bulk)",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.isperfect",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.category",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.shortlabel",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.shortname",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.review_score",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.videoid",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.id",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.instanceid",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.instanceindex",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.program",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.has_rating",
"url":15,
"doc":"Deprecated",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.has_rating_score",
"url":15,
"doc":"WARNING: do not rely on this function. If the scoring lambda falls behind for some reason, this will not be correct. Use pycollector.admin.project.Project.ratedinstances() instead",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.ratings",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.rating",
"url":15,
"doc":"This function is very inefficient, do not use me at large scales unless ratings are provided in constructor",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.Rating",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.finalized",
"url":15,
"doc":"deprecated",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.isgood",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.is_good",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.rate",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.quicklookurl",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.animated_quicklookurl",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.actorcropurl",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.clip",
"url":15,
"doc":"Return just the clip for this instance. Calling quicklook() on this object should match the quicklook url. This myst be cast ast vipy.video.Scene so that instanceid() is preserved.",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.untrimmedclip",
"url":15,
"doc":"Return just the untrimmed clip for this instance. This must be cast as vipy.video.Scene so that instanceid() is preserved correctly.",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.fullvideo",
"url":15,
"doc":"Return the full video containing this instance",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.topandas",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.bghash",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Instance.writeback",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.delete",
"url":15,
"doc":"Use with caution!",
"func":1
},
{
"ref":"pycollector.admin.video.last",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Resubmission",
"url":15,
"doc":""
},
{
"ref":"pycollector.admin.video.Resubmission.video",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Resubmission.videoid",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Resubmission.archive",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.video.Resubmission.project",
"url":15,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce",
"url":17,
"doc":""
},
{
"ref":"pycollector.admin.workforce.internal_collectors",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Subjects",
"url":17,
"doc":"Access the subject table and expose useful methods for manipulating subject attributes"
},
{
"ref":"pycollector.admin.workforce.Subjects.subjectid_to_email",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Subjects.email_to_subjectid",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Subjects.consent_videos",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Subjects.consent_video",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Subjects.consent_response",
"url":17,
"doc":"Consent responses are stored per collector per subject and not globally. - The subject ID may be unknown at collection time, and is randomly assigned by the app. - This random subbject ID is stored in the Subjects table, and reused when this subject is consented again - This random subject ID maps to the subject email address in the Subject table - We use the subject table to map the subject ID to subject email then cross reference to the collector table using this email address - This was changed in android 2.6.14 to match the storage format in iOS",
"func":1
},
{
"ref":"pycollector.admin.workforce.Subjects.consented_by",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Subjects.consentedby",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Subjects.consentedat",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Subjects.is_self_consented",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Subjects.isconsented",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Subjects.emails",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Subjects.delete",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors",
"url":17,
"doc":"Access the collector table and expose useful methods for manipulating collector attributes"
},
{
"ref":"pycollector.admin.workforce.Collectors.collectorid",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.dropbox_token",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.has_dropbox",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.email",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.emails",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.canonicalize_emails",
"url":17,
"doc":"Return email addresses that are registered that differ only by capitalization",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.email_address",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.iscollector",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.iscollectorid",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.subjectid_to_email",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.collectorid_to_email",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.email_to_collectorid",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.email_to_firstname",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.consent_video",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.get_active_collectors",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.sync_active_collectors",
"url":17,
"doc":"Sync active collectors from GSheet to DynamoDB Args: program_name (str, optional): program name. Defaults to None. project_name (str, optional): project name. Defaults to None.",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.get_collectors",
"url":17,
"doc":"Return all collectors Args: as_dataframe (bool, optional): export the collector data in Pandas dataframe. Defaults to False. Returns: Dict or Pandas dataframe: return collectors data",
"func":1
},
{
"ref":"pycollector.admin.workforce.Collectors.collector",
"url":17,
"doc":""
},
{
"ref":"pycollector.admin.workforce.internal_collectorid",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Twine",
"url":17,
"doc":"Read the Twine workforce sheet and expose this data for analysis"
},
{
"ref":"pycollector.admin.workforce.Twine.partner",
"url":17,
"doc":"Return twine partners. >>> list_of_all_partner_emails = Twine().partner(email=True) >>> list_of_partner_emails = Twine().partner(email='me@here.com') >>> list_of_all_partner_twineids = Twine().partner(twineid=True) >>> list_of_partner_twineids = Twine().partner(twineid='a_twine_id')",
"func":1
},
{
"ref":"pycollector.admin.workforce.Twine.email_to_id",
"url":17,
"doc":"Levenshtein distance for email typos",
"func":1
},
{
"ref":"pycollector.admin.workforce.Twine.id_to_email",
"url":17,
"doc":"Levenshtein distance for twineid typos",
"func":1
},
{
"ref":"pycollector.admin.workforce.Twine.isconsented",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Twine.locations",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Twine.emails",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Twine.twineids",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Twine.desanitize",
"url":17,
"doc":"Return dictionary mapping sanitized IDs to email address. See collector.dataset.Video().sanitize()",
"func":1
},
{
"ref":"pycollector.admin.workforce.Twine.istwineemail",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Twine.location",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Twine.groupid",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.workforce.Twine.device",
"url":17,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard",
"url":18,
"doc":""
},
{
"ref":"pycollector.admin.dashboard.Demographics",
"url":18,
"doc":""
},
{
"ref":"pycollector.admin.dashboard.Demographics.report",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Demographics.completed",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Demographics.iscompleted",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Consent",
"url":18,
"doc":""
},
{
"ref":"pycollector.admin.dashboard.Consent.more_info",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Consent.verbal_consent_statement",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Consent.questions",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Consent.sync",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector",
"url":18,
"doc":""
},
{
"ref":"pycollector.admin.dashboard.Collector.url",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector.show",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector.init",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector.update",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector.read",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector.sleep",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector.print",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector.disputed",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector.unprotect",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector.payment_history",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector.payment_total",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector.num_payment_by_collection",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector.num_rate_limited",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Collector.rate_limited_collections",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment",
"url":18,
"doc":""
},
{
"ref":"pycollector.admin.dashboard.Recruitment.quality",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.groupid",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.internal_collectors",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.has_repeated_location",
"url":18,
"doc":"Has a collector reused a location during this time period? Return a dictionary of collectorid",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.last_submission_timestamp",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.url",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.review_score",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.isapple",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.isandroid",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.device",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.roles",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.isadmin",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.iscollector",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.issupercollector",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.is_active_supercollector",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.is_active_collector",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.is_active_reviewer",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.is_active_super_reviewer",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.isdeveloper",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.isinternal",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.isreviewer",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.is_super_reviewer",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.num_reviewers",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.num_collectors",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.iswatcher",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.ismetareviewer",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.emails",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.active_collector_emails",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.active_supercollector_emails",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.active_submitter_emails",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.offboarded_collector_emails",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.offboarded",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.onboarded",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.isoffboarded",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.isonboarded",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.pending_onboard",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.pending_offboard",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.after_offboard_date",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.offboard_date",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.onboard_date",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.canonicalize",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.reviewers",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.super_reviewers",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.active_reviewers",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.active_super_reviewers",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.metareviewers",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.active_metareviewers",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.location",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.locations",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.countries",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.collectors",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.active_collectors",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.active_collector_team",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.active_submitters",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.offboarded_collectors",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.iphone_collectors",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.android_collectors",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.isrecruited",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.partner",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.private_dashboards",
"url":18,
"doc":"Use this with caution as it can result in ulimit violations",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.private_dashboard",
"url":18,
"doc":"Make a new sheet in the folder with a public URL",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Recruitment.notify",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels",
"url":18,
"doc":""
},
{
"ref":"pycollector.admin.dashboard.Labels.label_to_target",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.totarget",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.actor",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.objects",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.object",
"url":18,
"doc":"Other objects associated with this label - Does not include the actor",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.labels",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.activities",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.target_labels",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.target_objects",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.shortlabel",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.activity_shortlabels",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.isactivity",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.isobject",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.hasobject",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.style",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.actorpose",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.actorpose_description",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.illumination",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.location",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.viewpoint",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.viewpoint_description",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.style_description",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.description",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.is_person_person_activity",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.is_person_object_activity",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.is_object_person_activity",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Labels.is_person_activity",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Project",
"url":18,
"doc":""
},
{
"ref":"pycollector.admin.dashboard.Project.projects",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Project.names",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Project.program",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Project.isproject",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign",
"url":18,
"doc":""
},
{
"ref":"pycollector.admin.dashboard.Campaign.collections",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.collection",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.collection_by_name",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.iscollection",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.collectionlist",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.collection_names",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.enabled_collection_names",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.projects",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.project",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.program",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.sync",
"url":18,
"doc":"Sync campaign to Collection() table in DDB, deleting and creating new Activity(), Project(), Program() entries as needed",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.new_training_videos",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.training_videos",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.price_per_activity",
"url":18,
"doc":"Mean price per activity for enabled collections weighted by maximum allowable submissions",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.mean_price",
"url":18,
"doc":"Mean price per video for enabled collections weighted by maximum allowable submissions",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.num_live_collections",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Campaign.activitylist",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary",
"url":18,
"doc":""
},
{
"ref":"pycollector.admin.dashboard.Summary.read",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.keys",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.values",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.dict",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.program",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.islive",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.ispaused",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.timestamp",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.startdate",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.enddate",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.max_submissions",
"url":18,
"doc":"WARNING: This has been deprecated in favor of project or collection level max submissions",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.program_manager",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.program_name",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.price_per_video",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.collection_rate_limit",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.min_payment_score",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.totals",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.stats",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.sync",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Summary.campaign_complete",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard",
"url":18,
"doc":""
},
{
"ref":"pycollector.admin.dashboard.Dashboard.show",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.program",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.url",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.disputed",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.collector_team",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.internal_collectors",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.active_collectors",
"url":18,
"doc":"Return a list of all collectors active during a given week",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.consent_responses",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.total_by_instance",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.collector_assignment_report",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.assigned_collectors",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.onboard",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.offboard",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.sync",
"url":18,
"doc":"Write the provided Project() to the dashboard",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.cache",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.reassign",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.assign",
"url":18,
"doc":"Assign collections to workforce with collectorid",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.unassign",
"url":18,
"doc":"Unassign collections to collector with collector_id (may be list). If None, unassign all collectors from this program",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.assign_ratings",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.total_payments_made",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.payments_made",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.isarchived",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.last_archived",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.last_finalized",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.isfinalized",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.archive",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.finalize",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.sleep",
"url":18,
"doc":"Sleep for hours=hours, if rounded=True, then round to the nearest hour calibrated from midnight. If hours=4, then sleep until next 00:00, 04:00, 08:00, etc",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.hourly",
"url":18,
"doc":"Hourly sync operations for dashboard given optional project",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.quicklooks",
"url":18,
"doc":"Generate quicklooks for the provided instances",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.daily_reviews",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.audit",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.daily",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.weekly",
"url":18,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.dashboard.Dashboard.payments",
"url":18,
"doc":"Return a dictionary of planned payments for project organized by collector",
"func":1
},
{
"ref":"pycollector.admin.dashboard.stats",
"url":18,
"doc":"Return a dictionary of useful statistics about this project for dashboarding. Requires accessing the Collections()",
"func":1
},
{
"ref":"pycollector.admin.dashboard.receipt",
"url":18,
"doc":"Generate an itemized PDF receipt",
"func":1
},
{
"ref":"pycollector.admin.util",
"url":19,
"doc":""
},
{
"ref":"pycollector.admin.util.is_email_address",
"url":19,
"doc":"Quick and dirty, will throw an error on blank characters if strict=True",
"func":1
},
{
"ref":"pycollector.admin.util.sleepfor",
"url":19,
"doc":"Sleep for hours=hours, if rounded=True, then round to the nearest hour calibrated from midnight. If hours=4, then sleep until next 00:00, 04:00, 08:00, etc",
"func":1
},
{
"ref":"pycollector.admin.util.yyyymmdd_to_yyyyMonthdd",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.mergedict",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.tofloat",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.lowerif",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.isday",
"url":19,
"doc":"Is the yyyymmdd formatted as 'YYYY-MM-DD' such as '2020-03-18'",
"func":1
},
{
"ref":"pycollector.admin.util.isdate",
"url":19,
"doc":"Alias for isday",
"func":1
},
{
"ref":"pycollector.admin.util.fromdate",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.ismonday",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.issunday",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.istuesday",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.is_more_recent_than",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.yyyymmdd_to_date",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.fromdate_gsheets",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.allmondays",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.timestamp_YYYYMMDD_HHMMSS",
"url":19,
"doc":"Datetime stamp in eastern timezone with second resolution",
"func":1
},
{
"ref":"pycollector.admin.util.istimestamp_YYYYMMDD_HHMMSS",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.fromtimestamp_YYYYMMDD_HHMMSS",
"url":19,
"doc":"Assumed eastern timezone",
"func":1
},
{
"ref":"pycollector.admin.util.timestamp",
"url":19,
"doc":"Datetime stamp in eastern timezone with microsecond resolution",
"func":1
},
{
"ref":"pycollector.admin.util.totimestamp",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.ishtml",
"url":19,
"doc":"Is the file an HTMLfile",
"func":1
},
{
"ref":"pycollector.admin.util.istimestamp",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.isdatestamp",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.is_number_as_string",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.is_positive_number",
"url":19,
"doc":"Return True if s contains a positive number in any conformal type (e.g. strings, ints, floats)",
"func":1
},
{
"ref":"pycollector.admin.util.fromtimestamp",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.canonicalize",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.clockstamp",
"url":19,
"doc":"Datetime stamp in eastern timezone with second resolution",
"func":1
},
{
"ref":"pycollector.admin.util.datestamp",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.topenny",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.two_significant_digits",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.today",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.fromclockstamp",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.allmondays_since",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.allmondays_between",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.mondaysago",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.lastmonday",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.lastsunday",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.Ndaysago",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.daysago",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.lastweek_monday",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.nextsunday",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.nextmonday",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.nextday",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.timestamp_for_gsheets",
"url":19,
"doc":"Datetime stamp in eastern timezone suitable to write so that gsheets data validation of date does not throw a warning",
"func":1
},
{
"ref":"pycollector.admin.util.datestamp_for_gsheets",
"url":19,
"doc":"Datetime stamp in eastern timezone suitable to write so that gsheets data validation of date does not throw a warning",
"func":1
},
{
"ref":"pycollector.admin.util.get_reviewer_id",
"url":19,
"doc":"",
"func":1
},
{
"ref":"pycollector.admin.util.ddb_delete_all_items",
"url":19,
"doc":"delete all items from given dynamodb table Args: table (str): given dynamodb table PKey (str): partition key name Skey (str): sort key name",
"func":1
},
{
"ref":"pycollector.admin.util.ddb_delete_by_data",
"url":19,
"doc":"delete items from given dynamodb table by given data Args: table (str): given dynamodb table data (Dict): data in pyhton dictionary form PKey (str): partition key name SKey (str): sort key name",
"func":1
},
{
"ref":"pycollector.program",
"url":20,
"doc":""
},
{
"ref":"pycollector.program.briar",
"url":21,
"doc":""
},
{
"ref":"pycollector.program.briar.BRIAR",
"url":21,
"doc":""
},
{
"ref":"pycollector.program.briar.BRIAR.dashboard",
"url":21,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.briar.BRIAR.assign",
"url":10,
"doc":"Assign all active projects for this program to the list of collector IDs",
"func":1
},
{
"ref":"pycollector.program.briar.program",
"url":21,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.briar.dashboard",
"url":21,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.briar.new",
"url":21,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.llfr",
"url":22,
"doc":""
},
{
"ref":"pycollector.program.llfr.LLFR",
"url":22,
"doc":""
},
{
"ref":"pycollector.program.llfr.LLFR.dashboard",
"url":22,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.llfr.LLFR.assign",
"url":10,
"doc":"Assign all active projects for this program to the list of collector IDs",
"func":1
},
{
"ref":"pycollector.program.llfr.program",
"url":22,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.llfr.dashboard",
"url":22,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.llfr.new",
"url":22,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.meva",
"url":23,
"doc":""
},
{
"ref":"pycollector.program.meva.MEVA",
"url":23,
"doc":""
},
{
"ref":"pycollector.program.meva.MEVA.assign",
"url":10,
"doc":"Assign all active projects for this program to the list of collector IDs",
"func":1
},
{
"ref":"pycollector.program.meva.program",
"url":23,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.meva.dryrun",
"url":23,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.meva.dashboard",
"url":23,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.pip",
"url":24,
"doc":""
},
{
"ref":"pycollector.program.pip.PIP",
"url":24,
"doc":""
},
{
"ref":"pycollector.program.pip.PIP.dashboard",
"url":24,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.pip.PIP.assign",
"url":10,
"doc":"Assign all active projects for this program to the list of collector IDs",
"func":1
},
{
"ref":"pycollector.program.pip.program",
"url":24,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.pip.dashboard",
"url":24,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.pip.new",
"url":24,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.practice",
"url":25,
"doc":""
},
{
"ref":"pycollector.program.practice.Practice",
"url":25,
"doc":""
},
{
"ref":"pycollector.program.practice.Practice.assign",
"url":25,
"doc":"Assign all active projects for this program to the list of collector IDs",
"func":1
},
{
"ref":"pycollector.program.practice.program",
"url":25,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.practice.dashboard",
"url":25,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.practice.set_training_videos",
"url":25,
"doc":"Add a randomly selected set of 50 training videos to the tutorial collection",
"func":1
},
{
"ref":"pycollector.program.registry",
"url":26,
"doc":""
},
{
"ref":"pycollector.program.registry.Registry",
"url":26,
"doc":""
},
{
"ref":"pycollector.program.registry.Registry.active_campaigns",
"url":26,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.registry.Registry.archived_campaigns",
"url":26,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.registry.Registry.isprogram",
"url":26,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.registry.Registry.program",
"url":26,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.registry.Registry.clone",
"url":26,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.registry.Registry.names",
"url":26,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.registry.Registry.dashboards",
"url":26,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.registry.Registry.show",
"url":26,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.cap",
"url":27,
"doc":""
},
{
"ref":"pycollector.program.cap.CAP",
"url":27,
"doc":""
},
{
"ref":"pycollector.program.cap.CAP.dashboard",
"url":27,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.cap.CAP.assign",
"url":10,
"doc":"Assign all active projects for this program to the list of collector IDs",
"func":1
},
{
"ref":"pycollector.program.cap.program",
"url":27,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.cap.dashboard",
"url":27,
"doc":"",
"func":1
},
{
"ref":"pycollector.program.cap.new",
"url":27,
"doc":"",
"func":1
},
{
"ref":"pycollector.backend",
"url":28,
"doc":""
},
{
"ref":"pycollector.backend.API",
"url":28,
"doc":"class for pycollector API Args: object ([type]): [description] Args: username ([type], optional): [description]. Defaults to None. password ([type], optional): [description]. Defaults to None."
},
{
"ref":"pycollector.backend.API.get_project",
"url":28,
"doc":"[summary] Args: -",
"func":1
},
{
"ref":"pycollector.backend.API.videos",
"url":28,
"doc":"[summary] Args: -",
"func":1
},
{
"ref":"pycollector.backend.API.lastvideo",
"url":28,
"doc":"",
"func":1
},
{
"ref":"pycollector.backend.API.new_collection",
"url":28,
"doc":"",
"func":1
},
{
"ref":"pycollector.backend.API.list_collections",
"url":28,
"doc":"",
"func":1
},
{
"ref":"pycollector.backend.API.delete_collection",
"url":28,
"doc":"",
"func":1
},
{
"ref":"pycollector.backend.API.login",
"url":29,
"doc":"[summary] Args: username ([str]): username of pycollector. password ([str], optional): password for the user. Defaults to None.",
"func":1
},
{
"ref":"pycollector.backend.API.get_ssm_param",
"url":29,
"doc":"[summary]",
"func":1
},
{
"ref":"pycollector.backend.API.is_token_expired",
"url":29,
"doc":"[summary] Returns: [type]: [description]",
"func":1
},
{
"ref":"pycollector.backend.API.add_user_to_group",
"url":29,
"doc":"Check if the current user is already in the pycollector user group, if not add the user to group Returns: [type]: [description]",
"func":1
},
{
"ref":"pycollector.dataset",
"url":30,
"doc":""
},
{
"ref":"pycollector.dataset.disjoint_activities",
"url":30,
"doc":"",
"func":1
},
{
"ref":"pycollector.dataset.asmeva",
"url":30,
"doc":"Convert a list of collector.dataset.Video() to MEVA annotation style",
"func":1
},
{
"ref":"pycollector.dataset.TorchDataset",
"url":30,
"doc":"Moved to vipy.torch.TorchDataset"
},
{
"ref":"pycollector.dataset.TorchTensordir",
"url":30,
"doc":"Moved to vipy.torch.TorchTensordir"
},
{
"ref":"pycollector.dataset.Dataset",
"url":30,
"doc":"Additional methods beyond  vipy.dataset.Dataset that are specific to collector style datasets"
},
{
"ref":"pycollector.dataset.Dataset.collectors",
"url":30,
"doc":"",
"func":1
},
{
"ref":"pycollector.dataset.Dataset.subjects",
"url":30,
"doc":"",
"func":1
},
{
"ref":"pycollector.dataset.Dataset.os",
"url":30,
"doc":"",
"func":1
},
{
"ref":"pycollector.dataset.Dataset.device",
"url":30,
"doc":"",
"func":1
},
{
"ref":"pycollector.dataset.Dataset.geolocation",
"url":30,
"doc":"",
"func":1
},
{
"ref":"pycollector.dataset.Dataset.cast",
"url":30,
"doc":"",
"func":1
},
{
"ref":"pycollector.globals",
"url":31,
"doc":""
},
{
"ref":"pycollector.globals.cachedir",
"url":31,
"doc":"Set the location to save videos and JSON files when downloaded. This will default to the system temp directory if not set. -This can be set by default by creating the environment variable VIPY_CACHE='/path/to/newdir'",
"func":1
},
{
"ref":"pycollector.globals.logging",
"url":31,
"doc":"Single entry point for enabling/disabling logging vs. printing All vipy functions overload \"from vipy.globals import print\" for simplified readability of code. This global function redirects print or warn to using the standard logging module. If format is provided, this will create a basicConfig handler, but this should be configured by the end-user.",
"func":1
},
{
"ref":"pycollector.globals.warn",
"url":31,
"doc":"",
"func":1
},
{
"ref":"pycollector.globals.print",
"url":31,
"doc":"Main entry point for all print statements in the pycollector package. All pycollector code calls this to print helpful messages. -All print() statements in pycollector are overloaded to call pycollector.globals.print() so that it can be redirected to logging as needed -Printing can be disabled by calling pycollector.globals.silent() -Printing can be redirected to standard python logging by calling pycollector.globals.logging(True)",
"func":1
},
{
"ref":"pycollector.globals.verbose",
"url":31,
"doc":"",
"func":1
},
{
"ref":"pycollector.globals.silent",
"url":31,
"doc":"",
"func":1
},
{
"ref":"pycollector.project",
"url":32,
"doc":""
},
{
"ref":"pycollector.project.Project",
"url":32,
"doc":"collector.project.Project class Projects() are sets of CollectionInstances() and Instances() in a program. Args: username ([str]): username of pycollector. password ([str], optional): password for the user. Defaults to None."
},
{
"ref":"pycollector.project.Project.videos",
"url":32,
"doc":"",
"func":1
},
{
"ref":"pycollector.project.Project.last",
"url":32,
"doc":"",
"func":1
},
{
"ref":"pycollector.project.Project.login",
"url":29,
"doc":"[summary] Args: username ([str]): username of pycollector. password ([str], optional): password for the user. Defaults to None.",
"func":1
},
{
"ref":"pycollector.project.Project.get_ssm_param",
"url":29,
"doc":"[summary]",
"func":1
},
{
"ref":"pycollector.project.Project.is_token_expired",
"url":29,
"doc":"[summary] Returns: [type]: [description]",
"func":1
},
{
"ref":"pycollector.project.Project.add_user_to_group",
"url":29,
"doc":"Check if the current user is already in the pycollector user group, if not add the user to group Returns: [type]: [description]",
"func":1
},
{
"ref":"pycollector.user",
"url":29,
"doc":""
},
{
"ref":"pycollector.user.User",
"url":29,
"doc":"User class for collector's user management Args: username ([str]): username of pycollector. password ([str], optional): password for the user. Defaults to None."
},
{
"ref":"pycollector.user.User.refresh",
"url":29,
"doc":"",
"func":1
},
{
"ref":"pycollector.user.User.login",
"url":29,
"doc":"[summary] Args: username ([str]): username of pycollector. password ([str], optional): password for the user. Defaults to None.",
"func":1
},
{
"ref":"pycollector.user.User.get_ssm_param",
"url":29,
"doc":"[summary]",
"func":1
},
{
"ref":"pycollector.user.User.is_token_expired",
"url":29,
"doc":"[summary] Returns: [type]: [description]",
"func":1
},
{
"ref":"pycollector.user.User.token_expired_by",
"url":29,
"doc":"",
"func":1
},
{
"ref":"pycollector.user.User.is_authenticated",
"url":29,
"doc":"",
"func":1
},
{
"ref":"pycollector.user.User.add_user_to_group",
"url":29,
"doc":"Check if the current user is already in the pycollector user group, if not add the user to group Returns: [type]: [description]",
"func":1
},
{
"ref":"pycollector.user.User.username",
"url":29,
"doc":""
},
{
"ref":"pycollector.user.User.cognito_username",
"url":29,
"doc":""
},
{
"ref":"pycollector.user.User.lambda_client",
"url":29,
"doc":""
},
{
"ref":"pycollector.util",
"url":33,
"doc":""
},
{
"ref":"pycollector.util.mergedict",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.lowerif",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.isday",
"url":33,
"doc":"Is the yyyymmdd formatted as 'YYYY-MM-DD' such as '2020-03-18'",
"func":1
},
{
"ref":"pycollector.util.isdate",
"url":33,
"doc":"Alias for isday",
"func":1
},
{
"ref":"pycollector.util.fromdate",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.ismonday",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.is_more_recent_than",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.yyyymmdd_to_date",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.is_email_address",
"url":33,
"doc":"Quick and dirty, will throw an error on blank characters if strict=True",
"func":1
},
{
"ref":"pycollector.util.allmondays",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.timestamp_YYYYMMDD_HHMMSS",
"url":33,
"doc":"Datetime stamp in eastern timezone with second resolution",
"func":1
},
{
"ref":"pycollector.util.istimestamp_YYYYMMDD_HHMMSS",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.fromtimestamp_YYYYMMDD_HHMMSS",
"url":33,
"doc":"Assumed eastern timezone",
"func":1
},
{
"ref":"pycollector.util.timestamp",
"url":33,
"doc":"Datetime stamp in eastern timezone with microsecond resolution",
"func":1
},
{
"ref":"pycollector.util.istimestamp",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.fromtimestamp",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.clockstamp",
"url":33,
"doc":"Datetime stamp in eastern timezone with second resolution",
"func":1
},
{
"ref":"pycollector.util.datestamp",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.today",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.fromclockstamp",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.allmondays_since",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.lastmonday",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.lastweek_monday",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.nextsunday",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.util.nextday",
"url":33,
"doc":"",
"func":1
},
{
"ref":"pycollector.video",
"url":16,
"doc":""
},
{
"ref":"pycollector.video.Video",
"url":16,
"doc":"pycollector.video.Video class"
},
{
"ref":"pycollector.video.Video.cast",
"url":16,
"doc":"Cast a conformal vipy object to this class. This is useful for downcast and upcast conversion of video objects.",
"func":1
},
{
"ref":"pycollector.video.Video.from_json",
"url":16,
"doc":"Restore an object serialized with self.json() Usage:   vs = vipy.video.Scene.from_json(v.json(  ",
"func":1
},
{
"ref":"pycollector.video.Video.json",
"url":16,
"doc":"Return JSON encoded string of this object. This may fail if attributes contain non-json encodeable object",
"func":1
},
{
"ref":"pycollector.video.Video.appjson",
"url":16,
"doc":"Export JSON that is equivalent to the output of the mobile app, with annotations relative to the video file (not the filter chain)",
"func":1
},
{
"ref":"pycollector.video.Video.load_json",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.isedited",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.editedat",
"url":16,
"doc":"Android appends an '_ ' timestamp as milliseconds since epoch (POSIX timestamp), iOS will replace the first '_datetimestr' with a new datetimest",
"func":1
},
{
"ref":"pycollector.video.Video.edited",
"url":16,
"doc":"Return the datetime representation of the editedat() string",
"func":1
},
{
"ref":"pycollector.video.Video.variant",
"url":16,
"doc":"Category variant",
"func":1
},
{
"ref":"pycollector.video.Video.geolocation",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.fetch",
"url":16,
"doc":"Download JSON and MP4 if not already downloaded",
"func":1
},
{
"ref":"pycollector.video.Video.fetchvideo",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.fetchjson",
"url":16,
"doc":"Download JSON if not already downloaded",
"func":1
},
{
"ref":"pycollector.video.Video.is_json_loaded",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.hasjson",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.hasMP4",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.activity_categories",
"url":16,
"doc":"Return a set of unique activity categories in the video, not including object categories",
"func":1
},
{
"ref":"pycollector.video.Video.quicklooks",
"url":16,
"doc":"Return a vipy.image.Image object containing a montage quicklook for each of the activities in this video. Usage: >>> filenames = [im.saveas('/path/to/quicklook.jpg') for im in self.quicklooks()]",
"func":1
},
{
"ref":"pycollector.video.Video.trim",
"url":16,
"doc":"Temporally clip the video so that the video start is the beginning of the first activity, and the end of the video is the end of the last activity. Optionally add a temporal pad of padframes before and after the clip",
"func":1
},
{
"ref":"pycollector.video.Video.timestamp",
"url":16,
"doc":"Return collected_date from json as a datetime object, WARNING: older veresion of the app do not include timezone info in this string, so this datetime is not offset aware This timestamp is in the local timezone of the collector! Do not use this for any datetime arithmetic without assigning a timezone from the geolocation",
"func":1
},
{
"ref":"pycollector.video.Video.uploaded",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.metadata",
"url":16,
"doc":"Return a dictionary of metadata about this video. Args: k [str]: If provided, return just the specified key of the attributes dictionary, otherwise return the attributes dictionary Returns: The 'attributes' dictionary, or just the value for the provided key k if provided",
"func":1
},
{
"ref":"pycollector.video.Video.videoid",
"url":16,
"doc":"Return a unique video identifier for this video, as specified in the 'video_id' attribute, or by SHA1 hash of the  vipy.video.Video.filename and  vipy.video.Video.url . Args: newid: [str] If not None, then update the video_id as newid. Returns: The video ID if newid=None else self  note - If the video filename changes (e.g. from transformation), and video_id is not set in self.attributes, then the video ID will change. - If a video does not have a filename or URL or a video ID in the attributes, then this will return None - To preserve a video ID independent of transformations, set self.setattribute('video_id', ${MY_ID}), or pass in newid",
"func":1
},
{
"ref":"pycollector.video.Video.collectorid",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.subjectid",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.collectionid",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.collection_name",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.collection",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.duration",
"url":16,
"doc":"Video length in seconds",
"func":1
},
{
"ref":"pycollector.video.Video.quickshow",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.downcast",
"url":16,
"doc":"Convert from pycollector.video to vipy.video.Scene by downcasting class",
"func":1
},
{
"ref":"pycollector.video.Video.upcast",
"url":16,
"doc":"Convert from pycollector.video to pycollector.admin.video by upcasting class, available to admins only",
"func":1
},
{
"ref":"pycollector.video.Video.project",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.program",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.object_detection",
"url":16,
"doc":"Run an object detector on a given frame of video. It is more efficient to construct an ObjectDetector() object once and reuse it.",
"func":1
},
{
"ref":"pycollector.video.Video.face_detection",
"url":16,
"doc":"Run face detection on a given frame of video. It is more efficient to construct a FaceDetector() object once and reuse it.",
"func":1
},
{
"ref":"pycollector.video.Video.faces",
"url":16,
"doc":"Alias for face_detection",
"func":1
},
{
"ref":"pycollector.video.Video.appversion",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.Video.app_version",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.video.last",
"url":16,
"doc":"",
"func":1
},
{
"ref":"pycollector.label",
"url":34,
"doc":""
},
{
"ref":"pycollector.label.Label",
"url":34,
"doc":""
},
{
"ref":"pycollector.label.piplabel_to_mevalabel",
"url":34,
"doc":"",
"func":1
},
{
"ref":"pycollector.label.mevalabel_to_index",
"url":34,
"doc":"",
"func":1
},
{
"ref":"pycollector.label.piplabel_to_index",
"url":34,
"doc":"",
"func":1
},
{
"ref":"pycollector.label.pip_250k_powerset",
"url":34,
"doc":"",
"func":1
},
{
"ref":"pycollector.version",
"url":35,
"doc":""
},
{
"ref":"pycollector.version.num",
"url":35,
"doc":"",
"func":1
},
{
"ref":"pycollector.version.at_least_version",
"url":35,
"doc":"Is versionstring='X.Y.Z' at least the current version?",
"func":1
},
{
"ref":"pycollector.version.is_at_least",
"url":35,
"doc":"Synonym for at_least_version",
"func":1
},
{
"ref":"pycollector.version.is_exactly",
"url":35,
"doc":"",
"func":1
}
]