<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pycollector.model.yolov5.utils.metrics API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pycollector.model.yolov5.utils.metrics</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/collector/blob/8e91c58c553d8ac70f51d16657f3b02656682fda/pycollector/model/yolov5/utils/metrics.py#L0-L202" class="git-link">Browse git</a>
</summary>
<pre><code class="python"># Model validation metrics

from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
import torch

from . import general


def fitness(x):
    # Model fitness as a weighted combination of metrics
    w = [0.0, 0.0, 0.1, 0.9]  # weights for [P, R, mAP@0.5, mAP@0.5:0.95]
    return (x[:, :4] * w).sum(1)


def ap_per_class(tp, conf, pred_cls, target_cls, plot=False, save_dir=&#39;precision-recall_curve.png&#39;, names=[]):
    &#34;&#34;&#34; Compute the average precision, given the recall and precision curves.
    Source: https://github.com/rafaelpadilla/Object-Detection-Metrics.
    # Arguments
        tp:  True positives (nparray, nx1 or nx10).
        conf:  Objectness value from 0-1 (nparray).
        pred_cls:  Predicted object classes (nparray).
        target_cls:  True object classes (nparray).
        plot:  Plot precision-recall curve at mAP@0.5
        save_dir:  Plot save directory
    # Returns
        The average precision as computed in py-faster-rcnn.
    &#34;&#34;&#34;

    # Sort by objectness
    i = np.argsort(-conf)
    tp, conf, pred_cls = tp[i], conf[i], pred_cls[i]

    # Find unique classes
    unique_classes = np.unique(target_cls)

    # Create Precision-Recall curve and compute AP for each class
    px, py = np.linspace(0, 1, 1000), []  # for plotting
    pr_score = 0.1  # score to evaluate P and R https://github.com/ultralytics/yolov3/issues/898
    s = [unique_classes.shape[0], tp.shape[1]]  # number class, number iou thresholds (i.e. 10 for mAP0.5...0.95)
    ap, p, r = np.zeros(s), np.zeros(s), np.zeros(s)
    for ci, c in enumerate(unique_classes):
        i = pred_cls == c
        n_l = (target_cls == c).sum()  # number of labels
        n_p = i.sum()  # number of predictions

        if n_p == 0 or n_l == 0:
            continue
        else:
            # Accumulate FPs and TPs
            fpc = (1 - tp[i]).cumsum(0)
            tpc = tp[i].cumsum(0)

            # Recall
            recall = tpc / (n_l + 1e-16)  # recall curve
            r[ci] = np.interp(-pr_score, -conf[i], recall[:, 0])  # r at pr_score, negative x, xp because xp decreases

            # Precision
            precision = tpc / (tpc + fpc)  # precision curve
            p[ci] = np.interp(-pr_score, -conf[i], precision[:, 0])  # p at pr_score

            # AP from recall-precision curve
            for j in range(tp.shape[1]):
                ap[ci, j], mpre, mrec = compute_ap(recall[:, j], precision[:, j])
                if plot and (j == 0):
                    py.append(np.interp(px, mrec, mpre))  # precision at mAP@0.5

    # Compute F1 score (harmonic mean of precision and recall)
    f1 = 2 * p * r / (p + r + 1e-16)

    if plot:
        plot_pr_curve(px, py, ap, save_dir, names)

    return p, r, ap, f1, unique_classes.astype(&#39;int32&#39;)


def compute_ap(recall, precision):
    &#34;&#34;&#34; Compute the average precision, given the recall and precision curves.
    Source: https://github.com/rbgirshick/py-faster-rcnn.
    # Arguments
        recall:    The recall curve (list).
        precision: The precision curve (list).
    # Returns
        The average precision as computed in py-faster-rcnn.
    &#34;&#34;&#34;

    # Append sentinel values to beginning and end
    mrec = recall  # np.concatenate(([0.], recall, [recall[-1] + 1E-3]))
    mpre = precision  # np.concatenate(([0.], precision, [0.]))

    # Compute the precision envelope
    mpre = np.flip(np.maximum.accumulate(np.flip(mpre)))

    # Integrate area under curve
    method = &#39;interp&#39;  # methods: &#39;continuous&#39;, &#39;interp&#39;
    if method == &#39;interp&#39;:
        x = np.linspace(0, 1, 101)  # 101-point interp (COCO)
        ap = np.trapz(np.interp(x, mrec, mpre), x)  # integrate
    else:  # &#39;continuous&#39;
        i = np.where(mrec[1:] != mrec[:-1])[0]  # points where x axis (recall) changes
        ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1])  # area under curve

    return ap, mpre, mrec


class ConfusionMatrix:
    # Updated version of https://github.com/kaanakan/object_detection_confusion_matrix
    def __init__(self, nc, conf=0.25, iou_thres=0.45):
        self.matrix = np.zeros((nc + 1, nc + 1))
        self.nc = nc  # number of classes
        self.conf = conf
        self.iou_thres = iou_thres

    def process_batch(self, detections, labels):
        &#34;&#34;&#34;
        Return intersection-over-union (Jaccard index) of boxes.
        Both sets of boxes are expected to be in (x1, y1, x2, y2) format.
        Arguments:
            detections (Array[N, 6]), x1, y1, x2, y2, conf, class
            labels (Array[M, 5]), class, x1, y1, x2, y2
        Returns:
            None, updates confusion matrix accordingly
        &#34;&#34;&#34;
        detections = detections[detections[:, 4] &gt; self.conf]
        gt_classes = labels[:, 0].int()
        detection_classes = detections[:, 5].int()
        iou = general.box_iou(labels[:, 1:], detections[:, :4])

        x = torch.where(iou &gt; self.iou_thres)
        if x[0].shape[0]:
            matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()
            if x[0].shape[0] &gt; 1:
                matches = matches[matches[:, 2].argsort()[::-1]]
                matches = matches[np.unique(matches[:, 1], return_index=True)[1]]
                matches = matches[matches[:, 2].argsort()[::-1]]
                matches = matches[np.unique(matches[:, 0], return_index=True)[1]]
        else:
            matches = np.zeros((0, 3))

        n = matches.shape[0] &gt; 0
        m0, m1, _ = matches.transpose().astype(np.int16)
        for i, gc in enumerate(gt_classes):
            j = m0 == i
            if n and sum(j) == 1:
                self.matrix[gc, detection_classes[m1[j]]] += 1  # correct
            else:
                self.matrix[gc, self.nc] += 1  # background FP

        if n:
            for i, dc in enumerate(detection_classes):
                if not any(m1 == i):
                    self.matrix[self.nc, dc] += 1  # background FN

    def matrix(self):
        return self.matrix

    def plot(self, save_dir=&#39;&#39;, names=()):
        try:
            import seaborn as sn

            array = self.matrix / (self.matrix.sum(0).reshape(1, self.nc + 1) + 1E-6)  # normalize
            array[array &lt; 0.005] = np.nan  # don&#39;t annotate (would appear as 0.00)

            fig = plt.figure(figsize=(12, 9))
            sn.set(font_scale=1.0 if self.nc &lt; 50 else 0.8)  # for label size
            labels = (0 &lt; len(names) &lt; 99) and len(names) == self.nc  # apply names to ticklabels
            sn.heatmap(array, annot=self.nc &lt; 30, annot_kws={&#34;size&#34;: 8}, cmap=&#39;Blues&#39;, fmt=&#39;.2f&#39;, square=True,
                       xticklabels=names + [&#39;background FN&#39;] if labels else &#34;auto&#34;,
                       yticklabels=names + [&#39;background FP&#39;] if labels else &#34;auto&#34;).set_facecolor((1, 1, 1))
            fig.axes[0].set_xlabel(&#39;True&#39;)
            fig.axes[0].set_ylabel(&#39;Predicted&#39;)
            fig.tight_layout()
            fig.savefig(Path(save_dir) / &#39;confusion_matrix.png&#39;, dpi=250)
        except Exception as e:
            pass

    def print(self):
        for i in range(self.nc + 1):
            print(&#39; &#39;.join(map(str, self.matrix[i])))


# Plots ----------------------------------------------------------------------------------------------------------------

def plot_pr_curve(px, py, ap, save_dir=&#39;.&#39;, names=()):
    fig, ax = plt.subplots(1, 1, figsize=(9, 6))
    py = np.stack(py, axis=1)

    if 0 &lt; len(names) &lt; 21:  # show mAP in legend if &lt; 10 classes
        for i, y in enumerate(py.T):
            ax.plot(px, y, linewidth=1, label=f&#39;{names[i]} %.3f&#39; % ap[i, 0])  # plot(recall, precision)
    else:
        ax.plot(px, py, linewidth=1, color=&#39;grey&#39;)  # plot(recall, precision)

    ax.plot(px, py.mean(1), linewidth=3, color=&#39;blue&#39;, label=&#39;all classes %.3f mAP@0.5&#39; % ap[:, 0].mean())
    ax.set_xlabel(&#39;Recall&#39;)
    ax.set_ylabel(&#39;Precision&#39;)
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    plt.legend(bbox_to_anchor=(1.04, 1), loc=&#34;upper left&#34;)
    fig.tight_layout()
    fig.savefig(Path(save_dir) / &#39;precision_recall_curve.png&#39;, dpi=250)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pycollector.model.yolov5.utils.metrics.ap_per_class"><code class="name flex">
<span>def <span class="ident">ap_per_class</span></span>(<span>tp, conf, pred_cls, target_cls, plot=False, save_dir='precision-recall_curve.png', names=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the average precision, given the recall and precision curves.
Source: <a href="https://github.com/rafaelpadilla/Object-Detection-Metrics.">https://github.com/rafaelpadilla/Object-Detection-Metrics.</a></p>
<h1 id="arguments">Arguments</h1>
<pre><code>tp:  True positives (nparray, nx1 or nx10).
conf:  Objectness value from 0-1 (nparray).
pred_cls:  Predicted object classes (nparray).
target_cls:  True object classes (nparray).
plot:  Plot precision-recall curve at mAP@0.5
save_dir:  Plot save directory
</code></pre>
<h1 id="returns">Returns</h1>
<pre><code>The average precision as computed in py-faster-rcnn.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/collector/blob/8e91c58c553d8ac70f51d16657f3b02656682fda/pycollector/model/yolov5/utils/metrics.py#L18-L76" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ap_per_class(tp, conf, pred_cls, target_cls, plot=False, save_dir=&#39;precision-recall_curve.png&#39;, names=[]):
    &#34;&#34;&#34; Compute the average precision, given the recall and precision curves.
    Source: https://github.com/rafaelpadilla/Object-Detection-Metrics.
    # Arguments
        tp:  True positives (nparray, nx1 or nx10).
        conf:  Objectness value from 0-1 (nparray).
        pred_cls:  Predicted object classes (nparray).
        target_cls:  True object classes (nparray).
        plot:  Plot precision-recall curve at mAP@0.5
        save_dir:  Plot save directory
    # Returns
        The average precision as computed in py-faster-rcnn.
    &#34;&#34;&#34;

    # Sort by objectness
    i = np.argsort(-conf)
    tp, conf, pred_cls = tp[i], conf[i], pred_cls[i]

    # Find unique classes
    unique_classes = np.unique(target_cls)

    # Create Precision-Recall curve and compute AP for each class
    px, py = np.linspace(0, 1, 1000), []  # for plotting
    pr_score = 0.1  # score to evaluate P and R https://github.com/ultralytics/yolov3/issues/898
    s = [unique_classes.shape[0], tp.shape[1]]  # number class, number iou thresholds (i.e. 10 for mAP0.5...0.95)
    ap, p, r = np.zeros(s), np.zeros(s), np.zeros(s)
    for ci, c in enumerate(unique_classes):
        i = pred_cls == c
        n_l = (target_cls == c).sum()  # number of labels
        n_p = i.sum()  # number of predictions

        if n_p == 0 or n_l == 0:
            continue
        else:
            # Accumulate FPs and TPs
            fpc = (1 - tp[i]).cumsum(0)
            tpc = tp[i].cumsum(0)

            # Recall
            recall = tpc / (n_l + 1e-16)  # recall curve
            r[ci] = np.interp(-pr_score, -conf[i], recall[:, 0])  # r at pr_score, negative x, xp because xp decreases

            # Precision
            precision = tpc / (tpc + fpc)  # precision curve
            p[ci] = np.interp(-pr_score, -conf[i], precision[:, 0])  # p at pr_score

            # AP from recall-precision curve
            for j in range(tp.shape[1]):
                ap[ci, j], mpre, mrec = compute_ap(recall[:, j], precision[:, j])
                if plot and (j == 0):
                    py.append(np.interp(px, mrec, mpre))  # precision at mAP@0.5

    # Compute F1 score (harmonic mean of precision and recall)
    f1 = 2 * p * r / (p + r + 1e-16)

    if plot:
        plot_pr_curve(px, py, ap, save_dir, names)

    return p, r, ap, f1, unique_classes.astype(&#39;int32&#39;)</code></pre>
</details>
</dd>
<dt id="pycollector.model.yolov5.utils.metrics.compute_ap"><code class="name flex">
<span>def <span class="ident">compute_ap</span></span>(<span>recall, precision)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the average precision, given the recall and precision curves.
Source: <a href="https://github.com/rbgirshick/py-faster-rcnn.">https://github.com/rbgirshick/py-faster-rcnn.</a></p>
<h1 id="arguments">Arguments</h1>
<pre><code>recall:    The recall curve (list).
precision: The precision curve (list).
</code></pre>
<h1 id="returns">Returns</h1>
<pre><code>The average precision as computed in py-faster-rcnn.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/collector/blob/8e91c58c553d8ac70f51d16657f3b02656682fda/pycollector/model/yolov5/utils/metrics.py#L79-L105" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def compute_ap(recall, precision):
    &#34;&#34;&#34; Compute the average precision, given the recall and precision curves.
    Source: https://github.com/rbgirshick/py-faster-rcnn.
    # Arguments
        recall:    The recall curve (list).
        precision: The precision curve (list).
    # Returns
        The average precision as computed in py-faster-rcnn.
    &#34;&#34;&#34;

    # Append sentinel values to beginning and end
    mrec = recall  # np.concatenate(([0.], recall, [recall[-1] + 1E-3]))
    mpre = precision  # np.concatenate(([0.], precision, [0.]))

    # Compute the precision envelope
    mpre = np.flip(np.maximum.accumulate(np.flip(mpre)))

    # Integrate area under curve
    method = &#39;interp&#39;  # methods: &#39;continuous&#39;, &#39;interp&#39;
    if method == &#39;interp&#39;:
        x = np.linspace(0, 1, 101)  # 101-point interp (COCO)
        ap = np.trapz(np.interp(x, mrec, mpre), x)  # integrate
    else:  # &#39;continuous&#39;
        i = np.where(mrec[1:] != mrec[:-1])[0]  # points where x axis (recall) changes
        ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1])  # area under curve

    return ap, mpre, mrec</code></pre>
</details>
</dd>
<dt id="pycollector.model.yolov5.utils.metrics.fitness"><code class="name flex">
<span>def <span class="ident">fitness</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/collector/blob/8e91c58c553d8ac70f51d16657f3b02656682fda/pycollector/model/yolov5/utils/metrics.py#L12-L15" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fitness(x):
    # Model fitness as a weighted combination of metrics
    w = [0.0, 0.0, 0.1, 0.9]  # weights for [P, R, mAP@0.5, mAP@0.5:0.95]
    return (x[:, :4] * w).sum(1)</code></pre>
</details>
</dd>
<dt id="pycollector.model.yolov5.utils.metrics.plot_pr_curve"><code class="name flex">
<span>def <span class="ident">plot_pr_curve</span></span>(<span>px, py, ap, save_dir='.', names=())</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/collector/blob/8e91c58c553d8ac70f51d16657f3b02656682fda/pycollector/model/yolov5/utils/metrics.py#L186-L203" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot_pr_curve(px, py, ap, save_dir=&#39;.&#39;, names=()):
    fig, ax = plt.subplots(1, 1, figsize=(9, 6))
    py = np.stack(py, axis=1)

    if 0 &lt; len(names) &lt; 21:  # show mAP in legend if &lt; 10 classes
        for i, y in enumerate(py.T):
            ax.plot(px, y, linewidth=1, label=f&#39;{names[i]} %.3f&#39; % ap[i, 0])  # plot(recall, precision)
    else:
        ax.plot(px, py, linewidth=1, color=&#39;grey&#39;)  # plot(recall, precision)

    ax.plot(px, py.mean(1), linewidth=3, color=&#39;blue&#39;, label=&#39;all classes %.3f mAP@0.5&#39; % ap[:, 0].mean())
    ax.set_xlabel(&#39;Recall&#39;)
    ax.set_ylabel(&#39;Precision&#39;)
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    plt.legend(bbox_to_anchor=(1.04, 1), loc=&#34;upper left&#34;)
    fig.tight_layout()
    fig.savefig(Path(save_dir) / &#39;precision_recall_curve.png&#39;, dpi=250)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pycollector.model.yolov5.utils.metrics.ConfusionMatrix"><code class="flex name class">
<span>class <span class="ident">ConfusionMatrix</span></span>
<span>(</span><span>nc, conf=0.25, iou_thres=0.45)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/collector/blob/8e91c58c553d8ac70f51d16657f3b02656682fda/pycollector/model/yolov5/utils/metrics.py#L108-L181" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ConfusionMatrix:
    # Updated version of https://github.com/kaanakan/object_detection_confusion_matrix
    def __init__(self, nc, conf=0.25, iou_thres=0.45):
        self.matrix = np.zeros((nc + 1, nc + 1))
        self.nc = nc  # number of classes
        self.conf = conf
        self.iou_thres = iou_thres

    def process_batch(self, detections, labels):
        &#34;&#34;&#34;
        Return intersection-over-union (Jaccard index) of boxes.
        Both sets of boxes are expected to be in (x1, y1, x2, y2) format.
        Arguments:
            detections (Array[N, 6]), x1, y1, x2, y2, conf, class
            labels (Array[M, 5]), class, x1, y1, x2, y2
        Returns:
            None, updates confusion matrix accordingly
        &#34;&#34;&#34;
        detections = detections[detections[:, 4] &gt; self.conf]
        gt_classes = labels[:, 0].int()
        detection_classes = detections[:, 5].int()
        iou = general.box_iou(labels[:, 1:], detections[:, :4])

        x = torch.where(iou &gt; self.iou_thres)
        if x[0].shape[0]:
            matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()
            if x[0].shape[0] &gt; 1:
                matches = matches[matches[:, 2].argsort()[::-1]]
                matches = matches[np.unique(matches[:, 1], return_index=True)[1]]
                matches = matches[matches[:, 2].argsort()[::-1]]
                matches = matches[np.unique(matches[:, 0], return_index=True)[1]]
        else:
            matches = np.zeros((0, 3))

        n = matches.shape[0] &gt; 0
        m0, m1, _ = matches.transpose().astype(np.int16)
        for i, gc in enumerate(gt_classes):
            j = m0 == i
            if n and sum(j) == 1:
                self.matrix[gc, detection_classes[m1[j]]] += 1  # correct
            else:
                self.matrix[gc, self.nc] += 1  # background FP

        if n:
            for i, dc in enumerate(detection_classes):
                if not any(m1 == i):
                    self.matrix[self.nc, dc] += 1  # background FN

    def matrix(self):
        return self.matrix

    def plot(self, save_dir=&#39;&#39;, names=()):
        try:
            import seaborn as sn

            array = self.matrix / (self.matrix.sum(0).reshape(1, self.nc + 1) + 1E-6)  # normalize
            array[array &lt; 0.005] = np.nan  # don&#39;t annotate (would appear as 0.00)

            fig = plt.figure(figsize=(12, 9))
            sn.set(font_scale=1.0 if self.nc &lt; 50 else 0.8)  # for label size
            labels = (0 &lt; len(names) &lt; 99) and len(names) == self.nc  # apply names to ticklabels
            sn.heatmap(array, annot=self.nc &lt; 30, annot_kws={&#34;size&#34;: 8}, cmap=&#39;Blues&#39;, fmt=&#39;.2f&#39;, square=True,
                       xticklabels=names + [&#39;background FN&#39;] if labels else &#34;auto&#34;,
                       yticklabels=names + [&#39;background FP&#39;] if labels else &#34;auto&#34;).set_facecolor((1, 1, 1))
            fig.axes[0].set_xlabel(&#39;True&#39;)
            fig.axes[0].set_ylabel(&#39;Predicted&#39;)
            fig.tight_layout()
            fig.savefig(Path(save_dir) / &#39;confusion_matrix.png&#39;, dpi=250)
        except Exception as e:
            pass

    def print(self):
        for i in range(self.nc + 1):
            print(&#39; &#39;.join(map(str, self.matrix[i])))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycollector.model.yolov5.utils.metrics.ConfusionMatrix.matrix"><code class="name flex">
<span>def <span class="ident">matrix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/collector/blob/8e91c58c553d8ac70f51d16657f3b02656682fda/pycollector/model/yolov5/utils/metrics.py#L156-L157" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def matrix(self):
    return self.matrix</code></pre>
</details>
</dd>
<dt id="pycollector.model.yolov5.utils.metrics.ConfusionMatrix.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, save_dir='', names=())</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/collector/blob/8e91c58c553d8ac70f51d16657f3b02656682fda/pycollector/model/yolov5/utils/metrics.py#L159-L177" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot(self, save_dir=&#39;&#39;, names=()):
    try:
        import seaborn as sn

        array = self.matrix / (self.matrix.sum(0).reshape(1, self.nc + 1) + 1E-6)  # normalize
        array[array &lt; 0.005] = np.nan  # don&#39;t annotate (would appear as 0.00)

        fig = plt.figure(figsize=(12, 9))
        sn.set(font_scale=1.0 if self.nc &lt; 50 else 0.8)  # for label size
        labels = (0 &lt; len(names) &lt; 99) and len(names) == self.nc  # apply names to ticklabels
        sn.heatmap(array, annot=self.nc &lt; 30, annot_kws={&#34;size&#34;: 8}, cmap=&#39;Blues&#39;, fmt=&#39;.2f&#39;, square=True,
                   xticklabels=names + [&#39;background FN&#39;] if labels else &#34;auto&#34;,
                   yticklabels=names + [&#39;background FP&#39;] if labels else &#34;auto&#34;).set_facecolor((1, 1, 1))
        fig.axes[0].set_xlabel(&#39;True&#39;)
        fig.axes[0].set_ylabel(&#39;Predicted&#39;)
        fig.tight_layout()
        fig.savefig(Path(save_dir) / &#39;confusion_matrix.png&#39;, dpi=250)
    except Exception as e:
        pass</code></pre>
</details>
</dd>
<dt id="pycollector.model.yolov5.utils.metrics.ConfusionMatrix.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/collector/blob/8e91c58c553d8ac70f51d16657f3b02656682fda/pycollector/model/yolov5/utils/metrics.py#L179-L181" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def print(self):
    for i in range(self.nc + 1):
        print(&#39; &#39;.join(map(str, self.matrix[i])))</code></pre>
</details>
</dd>
<dt id="pycollector.model.yolov5.utils.metrics.ConfusionMatrix.process_batch"><code class="name flex">
<span>def <span class="ident">process_batch</span></span>(<span>self, detections, labels)</span>
</code></dt>
<dd>
<div class="desc"><p>Return intersection-over-union (Jaccard index) of boxes.
Both sets of boxes are expected to be in (x1, y1, x2, y2) format.</p>
<h2 id="arguments">Arguments</h2>
<p>detections (Array[N, 6]), x1, y1, x2, y2, conf, class
labels (Array[M, 5]), class, x1, y1, x2, y2</p>
<h2 id="returns">Returns</h2>
<p>None, updates confusion matrix accordingly</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/collector/blob/8e91c58c553d8ac70f51d16657f3b02656682fda/pycollector/model/yolov5/utils/metrics.py#L116-L154" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def process_batch(self, detections, labels):
    &#34;&#34;&#34;
    Return intersection-over-union (Jaccard index) of boxes.
    Both sets of boxes are expected to be in (x1, y1, x2, y2) format.
    Arguments:
        detections (Array[N, 6]), x1, y1, x2, y2, conf, class
        labels (Array[M, 5]), class, x1, y1, x2, y2
    Returns:
        None, updates confusion matrix accordingly
    &#34;&#34;&#34;
    detections = detections[detections[:, 4] &gt; self.conf]
    gt_classes = labels[:, 0].int()
    detection_classes = detections[:, 5].int()
    iou = general.box_iou(labels[:, 1:], detections[:, :4])

    x = torch.where(iou &gt; self.iou_thres)
    if x[0].shape[0]:
        matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()
        if x[0].shape[0] &gt; 1:
            matches = matches[matches[:, 2].argsort()[::-1]]
            matches = matches[np.unique(matches[:, 1], return_index=True)[1]]
            matches = matches[matches[:, 2].argsort()[::-1]]
            matches = matches[np.unique(matches[:, 0], return_index=True)[1]]
    else:
        matches = np.zeros((0, 3))

    n = matches.shape[0] &gt; 0
    m0, m1, _ = matches.transpose().astype(np.int16)
    for i, gc in enumerate(gt_classes):
        j = m0 == i
        if n and sum(j) == 1:
            self.matrix[gc, detection_classes[m1[j]]] += 1  # correct
        else:
            self.matrix[gc, self.nc] += 1  # background FP

    if n:
        for i, dc in enumerate(detection_classes):
            if not any(m1 == i):
                self.matrix[self.nc, dc] += 1  # background FN</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Visym Collector" href="https://github.com/visym/collector/">
<img src="https://www.visym.com/labs/images/visym_logo_black_notext.png" alt="" width="150"> <p> </p>
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pycollector.model.yolov5.utils" href="index.html">pycollector.model.yolov5.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pycollector.model.yolov5.utils.metrics.ap_per_class" href="#pycollector.model.yolov5.utils.metrics.ap_per_class">ap_per_class</a></code></li>
<li><code><a title="pycollector.model.yolov5.utils.metrics.compute_ap" href="#pycollector.model.yolov5.utils.metrics.compute_ap">compute_ap</a></code></li>
<li><code><a title="pycollector.model.yolov5.utils.metrics.fitness" href="#pycollector.model.yolov5.utils.metrics.fitness">fitness</a></code></li>
<li><code><a title="pycollector.model.yolov5.utils.metrics.plot_pr_curve" href="#pycollector.model.yolov5.utils.metrics.plot_pr_curve">plot_pr_curve</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pycollector.model.yolov5.utils.metrics.ConfusionMatrix" href="#pycollector.model.yolov5.utils.metrics.ConfusionMatrix">ConfusionMatrix</a></code></h4>
<ul class="">
<li><code><a title="pycollector.model.yolov5.utils.metrics.ConfusionMatrix.matrix" href="#pycollector.model.yolov5.utils.metrics.ConfusionMatrix.matrix">matrix</a></code></li>
<li><code><a title="pycollector.model.yolov5.utils.metrics.ConfusionMatrix.plot" href="#pycollector.model.yolov5.utils.metrics.ConfusionMatrix.plot">plot</a></code></li>
<li><code><a title="pycollector.model.yolov5.utils.metrics.ConfusionMatrix.print" href="#pycollector.model.yolov5.utils.metrics.ConfusionMatrix.print">print</a></code></li>
<li><code><a title="pycollector.model.yolov5.utils.metrics.ConfusionMatrix.process_batch" href="#pycollector.model.yolov5.utils.metrics.ConfusionMatrix.process_batch">process_batch</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>